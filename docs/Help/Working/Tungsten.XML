<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>Tungsten</name>
  </assembly>
  <members>
    <member name="T:W.ActionQueue`1">
      <summary>
        <para>
            Allows the programmer to enqueue items for processing on a separate thread.  The ActionQueue will process items sequentially when an item is added.
            </para>
      </summary>
      <typeparam name="T">The type of data to enqueue and process</typeparam>
    </member>
    <member name="P:W.ActionQueue`1.Count">
      <summary>
            Returns the number of items currently in the queue
            </summary>
    </member>
    <member name="P:W.ActionQueue`1.Queue">
      <summary>
            The reference to the ConcurrentQueue being used
            </summary>
    </member>
    <member name="M:W.ActionQueue`1.Enqueue(`0)">
      <summary>
            Places an item in the queue
            </summary>
      <param name="item">The item to place in the queue</param>
    </member>
    <member name="M:W.ActionQueue`1.Cancel">
      <summary>
            Cancels processing of the queue
            </summary>
    </member>
    <member name="M:W.ActionQueue`1.Dispose">
      <summary>
            Releases resources related to the ActionQueue
            </summary>
    </member>
    <member name="M:W.ActionQueue`1.#ctor(System.Func{`0,System.Boolean},System.String)">
      <summary>
            Creates a new ActionQueue
            </summary>
      <param name="onItemAdded">A callback which is called whenever an item has been enqueued</param>
      <param name="caller">The name of the method which invoked this constructor</param>
    </member>
    <member name="M:W.ActionQueue`1.#ctor(System.Action{`0},System.String)">
      <summary>
            Creates a new ActionQueue
            </summary>
      <param name="onItemAdded">A callback which is called whenever an item has been enqueued</param>
      <param name="caller">The name of the method which invoked this constructor</param>
    </member>
    <member name="M:W.ActionQueue`1.Finalize">
      <summary>
            Disposes the ActionQueue
            </summary>
    </member>
    <member name="T:W.ArrayMethods">
      <summary>
            Methods to peek and modify arrays
            </summary>
    </member>
    <member name="M:W.ArrayMethods.PeekStart``1(``0[],System.Int32)">
      <summary>
            Retrieves the specified number of elements from the start of the array without changing the source array
            </summary>
      <typeparam name="T">The data type</typeparam>
      <param name="source">The source array</param>
      <param name="length">The number of elements to retrieve</param>
      <returns>A new array containing only the specified subset of elements</returns>
    </member>
    <member name="M:W.ArrayMethods.Peek``1(``0[],System.Int32,System.Int32)">
      <summary>
            Retrieves the specified range of elements from the array 
            </summary>
      <typeparam name="T">The data type</typeparam>
      <param name="source">The source array</param>
      <param name="startIndex">The index from which to start retrieving elements</param>
      <param name="length">The number of elements to retrieve</param>
      <returns>A new array containing only the specified subset of elements</returns>
    </member>
    <member name="M:W.ArrayMethods.PeekEnd``1(``0[],System.Int32)">
      <summary>
            Retrieves the specified number of elements from the end of the array
            </summary>
      <typeparam name="T">The data type</typeparam>
      <param name="source">The source array</param>
      <param name="length">The number of elements to retrieve</param>
      <returns>A new array containing only the specified subset of elements</returns>
    </member>
    <member name="M:W.ArrayMethods.TakeFromStart``1(``0[]@,System.Int32)">
      <summary>
            Retrieves and removes the specified number of elements from the start of the array
            </summary>
      <typeparam name="T">The data type</typeparam>
      <param name="source">The source array</param>
      <param name="length">The number of elements to retrieve</param>
      <returns>A new array containing only the specified subset of elements</returns>
    </member>
    <member name="M:W.ArrayMethods.Take``1(``0[]@,System.Int32,System.Int32)">
      <summary>
            Retrieves and removes the specified range of elements from the array
            </summary>
      <typeparam name="T">The data type</typeparam>
      <param name="source">The source array</param>
      <param name="startIndex">The index from which to start retrieving elements</param>
      <param name="length">The number of elements to retrieve</param>
      <returns>A new array containing only the specified subset of elements</returns>
    </member>
    <member name="M:W.ArrayMethods.TakeFromEnd``1(``0[]@,System.Int32)">
      <summary>
            Retrieves and removes the specified number of elements from the end of the array
            </summary>
      <typeparam name="T">The data type</typeparam>
      <param name="source">The source array</param>
      <param name="length">The number of elements to retrieve</param>
      <returns>A new array containing only the specified subset of elements</returns>
    </member>
    <member name="M:W.ArrayMethods.TrimStart``1(``0[]@,System.Int32)">
      <summary>
            Removes the specified number of elements from the start of the array, resizing the array as necessary
            </summary>
      <typeparam name="T">The data type</typeparam>
      <param name="source">The source array</param>
      <param name="length">The number of elements to remove</param>
      <returns>The modified source array</returns>
    </member>
    <member name="M:W.ArrayMethods.Trim``1(``0[]@,System.Int32,System.Int32)">
      <summary>
            Removes the specified range of elements from the array, resizing the array as necessary
            </summary>
      <typeparam name="T">The data type</typeparam>
      <param name="source">The source array</param>
      <param name="startIndex">The index from which to start removing elements</param>
      <param name="length">The number of elements to remove</param>
      <returns>The modified source array</returns>
    </member>
    <member name="M:W.ArrayMethods.TrimEnd``1(``0[]@,System.Int32)">
      <summary>
            Removes the specified number of elements from the end of the array, resizing the array as necessary
            </summary>
      <typeparam name="T">The data type</typeparam>
      <param name="source">The source array</param>
      <param name="length">The number of elements to remove</param>
      <returns>The modified source array</returns>
    </member>
    <member name="M:W.ArrayMethods.Append``1(``0[]@,``0[])">
      <summary>
            Appends the items to an array, resizing the array as necessary
            </summary>
      <typeparam name="T">The data type</typeparam>
      <param name="source">The source array</param>
      <param name="itemsToAdd">The array of items to append to the source</param>
      <returns>The modified source array</returns>
    </member>
    <member name="M:W.ArrayMethods.Insert``1(``0[]@,``0[],System.Int32)">
      <summary>
            Appends the items to an array, resizing the array as necessary
            </summary>
      <typeparam name="T">The data type</typeparam>
      <param name="source">The source array</param>
      <param name="itemsToInsert">The array of items to append to the source</param>
      <param name="index">The index where the items should be inserted</param>
      <returns>The modified source array</returns>
    </member>
    <member name="T:W.CallResult`1">
      <summary>
        <para>
            Generic class to be used as a return value.  CallResult encapsulates a success/failure, an exception and a return value.
            </para>
      </summary>
      <typeparam name="TResult">The type to be used for the Result member (the return value of the function)</typeparam>
    </member>
    <member name="P:W.CallResult`1.Result">
      <summary>
            The return value
            </summary>
    </member>
    <member name="M:W.CallResult`1.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:W.CallResult`1.#ctor(System.Boolean)">
      <summary>
            Constructor accepting an initial Success value
            </summary>
      <param name="success">The initial Success value</param>
    </member>
    <member name="M:W.CallResult`1.#ctor(System.Boolean,`0)">
      <summary>
            Constructor accepting an initial Success value and an initial Result value
            </summary>
      <param name="success">The initial Success value</param>
      <param name="result">The initial Result value</param>
    </member>
    <member name="M:W.CallResult`1.#ctor(System.Boolean,`0,System.Exception)">
      <summary>
            Constructor accepting an initial Success value, an initial Result value and an initial Exception value
            </summary>
      <param name="success">The initial value for Success</param>
      <param name="result">The initial Result value</param>
      <param name="e">An exception object, if an exception occurred</param>
    </member>
    <member name="P:W.CallResult`1.Empty">
      <summary>
            Provides a new instance of an uninitialized CallResult&lt;TResult&gt;
            </summary>
    </member>
    <member name="T:W.CallResult">
      <summary>
            A non-generic return value for a function.  CallResult encapsulates a success/failure and an exception.
            </summary>
    </member>
    <member name="P:W.CallResult.Success">
      <summary>
            Set to True if the function succeeds, otherwise False
            </summary>
    </member>
    <member name="P:W.CallResult.Exception">
      <summary>
            Provide exception data to the caller if desired
            </summary>
    </member>
    <member name="M:W.CallResult.#ctor">
      <summary>
            Default constructor, initializes Success to false
            </summary>
    </member>
    <member name="M:W.CallResult.#ctor(System.Boolean)">
      <summary>
            Constructor which accepts an initial value for Success
            </summary>
      <param name="success">The initial value for Success</param>
    </member>
    <member name="M:W.CallResult.#ctor(System.Boolean,System.Exception)">
      <summary>
            Constructor which accepts an initial value for Success and an initial value for Exception
            </summary>
      <param name="success">The initial value for Success</param>
      <param name="e">The initial value for Exception</param>
    </member>
    <member name="P:W.CallResult.Empty">
      <summary>
            Provides a new instance of an uninitialized CallResult
            </summary>
    </member>
    <member name="T:W.Disposable">
      <summary>
            Provides the Disposable pattern as a base class
            </summary>
    </member>
    <member name="F:W.Disposable.IsDisposed">
      <summary>
            If True, the object has been disposed
            </summary>
    </member>
    <member name="F:W.Disposable.IsDisposing">
      <summary>
            If True, the object is in the process of disposing
            </summary>
    </member>
    <member name="M:W.Disposable.OnDisposeUnmanaged">
      <summary>
            Override to release unmanaged objects
            </summary>
    </member>
    <member name="M:W.Disposable.OnDispose">
      <summary>
            Overload to dispose managed objects
            </summary>
    </member>
    <member name="M:W.Disposable.Dispose">
      <summary>
            This code added to correctly implement the disposable pattern.
            </summary>
    </member>
    <member name="T:W.Disposer">
      <summary>
        <para>Aids in implementing a clean Dispose method.  Supports re-entrancy but only calls the cleanup Action once.
            </para>
      </summary>
    </member>
    <member name="P:W.Disposer.IsDisposed">
      <summary>
            True if Cleanup has been called and completed, otherwise False
            </summary>
    </member>
    <member name="M:W.Disposer.Cleanup(System.Action)">
      <summary>
            Calls the action (should contain cleanup code)
            </summary>
      <param name="cleanupAction">The action to call</param>
    </member>
    <member name="M:W.Disposer.Cleanup(System.Object,System.Action)">
      <summary>
            Calls the action (should contain cleanup code)
            </summary>
      <param name="objToSupressFinalize">The object on which to suppress the finalizer call (usually the one currently being disposed)</param>
      <param name="cleanupAction">The action to call</param>
    </member>
    <member name="T:W.Encryption.AssymetricEncryption">
      <summary>
            Facilitates two way (assymetric) encryption via RSA cryptography
            </summary>
    </member>
    <member name="T:W.Encryption.AssymetricEncryption.ExchangeKeysDelegate">
      <summary>
            A delegate used by ExchangeKeys to facilitate the exchange of the public keys
            </summary>
      <param name="localPublicKey">The local public key</param>
      <returns>Return the remote public key</returns>
    </member>
    <member name="P:W.Encryption.AssymetricEncryption.PublicKey">
      <summary>
            The local public key
            </summary>
    </member>
    <member name="P:W.Encryption.AssymetricEncryption.RemotePublicKey">
      <summary>
            The remote's public key
            </summary>
    </member>
    <member name="M:W.Encryption.AssymetricEncryption.ExchangeKeys(W.Encryption.AssymetricEncryption.ExchangeKeysDelegate)">
      <summary>
        <para>
            Calls the function which completes the exchange and sets RemotePublicKey to the result.
            This function must be implemented by the developer and is contextual to his or her scenario.
            In all cases however, the return value must be the remote public key upon success, or null to specify a failure.
            </para>
      </summary>
      <param name="del">The function to call</param>
      <returns>True if RemotePublicKey was assigned a non-null value, otherwise False</returns>
    </member>
    <member name="M:W.Encryption.AssymetricEncryption.Encrypt(System.Byte[]@)">
      <summary>
            Encrypts data with the remote public key
            </summary>
      <param name="bytes">The data to encrypt with the remote public key</param>
      <returns>
      </returns>
    </member>
    <member name="M:W.Encryption.AssymetricEncryption.Decrypt(System.Byte[]@)">
      <summary>
            Decrypts data with the local private key
            </summary>
      <param name="bytes">The data to decrypt</param>
      <returns>The decrypted data</returns>
    </member>
    <member name="P:W.Encryption.AssymetricEncryption.LegalKeySizes">
      <summary>
            The legal RSA key sizes supported by the platform
            </summary>
    </member>
    <member name="M:W.Encryption.AssymetricEncryption.#ctor(System.Int32)">
      <summary>
            Constructs a new TwoWayEncryption instance
            </summary>
      <param name="keySize">The encryption key size</param>
    </member>
    <member name="T:W.Encryption.MD5">
      <summary>
            Used to generate MD5 hashes and verify input strings against them
            </summary>
    </member>
    <member name="M:W.Encryption.MD5.GetMd5Hash(System.String)">
      <summary>
            Generates an MD5 hash of the input string
            </summary>
      <param name="input">An MD5 hash of this input will be created</param>
      <returns>An MD5 hash of the inputted value</returns>
    </member>
    <member name="M:W.Encryption.MD5.GetMd5Hash(System.String,System.Security.Cryptography.MD5)">
      <summary>
            Generates an MD5 hash of the input string
            </summary>
      <param name="input">An MD5 hash of this input will be created</param>
      <param name="md5">The previously allocated MD5 object to use</param>
      <returns>An MD5 hash of the inputted value</returns>
    </member>
    <member name="M:W.Encryption.MD5.VerifyMd5Hash(System.String,System.String)">
      <summary>
            Verifies a hash against a string
            </summary>
      <param name="input">The string to verify</param>
      <param name="hash">The MD5 hash used in the verification</param>
      <returns>True if the input string is verified, otherwise False</returns>
    </member>
    <member name="T:W.Encryption.PublicPrivateKeyPair">
      <summary>
            The public and private RSA keys
            </summary>
    </member>
    <member name="P:W.Encryption.PublicPrivateKeyPair.PrivateKey">
      <summary>
            The private RSA key.  Should never be shared.
            </summary>
    </member>
    <member name="P:W.Encryption.PublicPrivateKeyPair.PublicKey">
      <summary>
            the public RSA key. Should be shared.
            </summary>
    </member>
    <member name="T:W.Encryption.RSAMethods">
            Warning is overriding an error
            XML comment has syntactically incorrect cref attribute
            <summary><para>
            Replaces RSA.  This code was adaptd for NetStandard from an article published on CodeProject by Mathew John Schlabaugh in 2007.  It is less complicated but works more often than my initial RSA implementation. See: https://www.codeproject.com/Articles/10877/Public-Key-RSA-Encryption-in-C-NET
            </para></summary><see cref="!:https://www.codeproject.com/Articles/10877/Public-Key-RSA-Encryption-in-C-NET" /></member>
    <member name="M:W.Encryption.RSAMethods.LegalKeySizes">
      <summary>
            Returns an arrary containing the supported key sizes
            </summary>
      <returns>An array of supported key sizes</returns>
    </member>
    <member name="M:W.Encryption.RSAMethods.CreateKeyPair(System.Int32)">
      <summary>
            Generates a public/private key pair
            </summary>
      <param name="keySize">The key size to use when creating the public and private keys</param>
      <returns>A newly created PublicPrivateKeyPair containing the public and private keys</returns>
    </member>
    <member name="M:W.Encryption.RSAMethods.Encrypt(System.String,System.Security.Cryptography.RSAParameters)">
      <summary>
            Encrypts a string using the specified keysize and public key
            </summary>
      <param name="inputString">The data to encrypt</param>
      <param name="publicKey">The public key used to encrypt the data</param>
      <returns>A string containing the encrypted data</returns>
    </member>
    <member name="M:W.Encryption.RSAMethods.Decrypt(System.String,System.Security.Cryptography.RSAParameters)">
      <summary>
            Decrypts a string which was previously encrypted with the Encrypt method
            </summary>
      <param name="cipher">The encrypted byte array</param>
      <param name="privateKey">The private key used to decrypt the data</param>
      <returns>A byte array containing the decrypted value</returns>
    </member>
    <member name="M:W.Encryption.RSAMethods.EncryptAsync(System.String,System.Security.Cryptography.RSAParameters)">
      <summary>
            Asynchronously encrypts a string using the specified keysize and public key
            </summary>
      <param name="inputString">The data to encrypt</param>
      <param name="publicKey">The public key used to encrypt the data</param>
      <returns>A string containing the encrypted data</returns>
    </member>
    <member name="M:W.Encryption.RSAMethods.DecryptAsync(System.String,System.Security.Cryptography.RSAParameters)">
      <summary>
            Asynchronously decrypts a string which was previously encrypted with the Encrypt method
            </summary>
      <param name="cipher">The encrypted byte array</param>
      <param name="privateKey">The private key used to decrypt the data</param>
      <returns>A byte array containing the decrypted value</returns>
    </member>
    <member name="T:W.EventTemplateDelegate">
      <summary>
            The template delegate
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
      <param name="args">An array of untyped arguments</param>
    </member>
    <member name="T:W.EventTemplateDelegate`1">
      <summary>
            The template delegate
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg">The detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="T:W.EventTemplateDelegate`2">
      <summary>
            The template delegate
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg1">The first detailed event argument</param>
      <param name="arg2">The second detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="T:W.EventTemplateDelegate`3">
      <summary>
            The template delegate
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg1">The first detailed event argument</param>
      <param name="arg2">The second detailed event argument</param>
      <param name="arg3">The third detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="T:W.EventTemplateDelegate`4">
      <summary>
            The template delegate
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg1">The first detailed event argument</param>
      <param name="arg2">The second detailed event argument</param>
      <param name="arg3">The third detailed event argument</param>
      <param name="arg4">The fourth detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="T:W.EventTemplateDelegate`5">
      <summary>
            The template delegate
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg1">The first detailed event argument</param>
      <param name="arg2">The second detailed event argument</param>
      <param name="arg3">The third detailed event argument</param>
      <param name="arg4">The fourth detailed event argument</param>
      <param name="arg5">The fifth detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="T:W.EventTemplate">
      <summary>
            Wraps the functionality of delegate, event and RaiseXXX into a single class
            </summary>
    </member>
    <member name="E:W.EventTemplate.OnRaised">
      <summary>
            The template event
            </summary>
    </member>
    <member name="M:W.EventTemplate.Raise(System.Object,System.String,System.Object[])">
      <summary>
            Raises the template event
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
      <param name="args">An array of untyped arguments</param>
    </member>
    <member name="T:W.EventTemplate`1">
      <summary>
            Wraps the functionality of delegate, event and RaiseXXX into a single class
            </summary>
      <typeparam name="TEventArg">The detailed event argument</typeparam>
    </member>
    <member name="E:W.EventTemplate`1.OnRaised">
      <summary>
            The template event
            </summary>
    </member>
    <member name="M:W.EventTemplate`1.Raise(System.Object,`0,System.String)">
      <summary>
            Raises the template event
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg">The detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="T:W.EventTemplate`2">
      <summary>
            Wraps the functionality of delegate, event and RaiseXXX into a single class
            </summary>
      <typeparam name="TEventArg1">The first detailed event argument</typeparam>
      <typeparam name="TEventArg2">The second detailed event argument</typeparam>
    </member>
    <member name="E:W.EventTemplate`2.OnRaised">
      <summary>
            The template event
            </summary>
    </member>
    <member name="M:W.EventTemplate`2.Raise(System.Object,`0,`1,System.String)">
      <summary>
            Raises the template event
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg1">The first detailed event argument</param>
      <param name="arg2">The second detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="T:W.EventTemplate`3">
      <summary>
            Wraps the functionality of delegate, event and RaiseXXX into a single class
            </summary>
      <typeparam name="TEventArg1">The first detailed event argument</typeparam>
      <typeparam name="TEventArg2">The second detailed event argument</typeparam>
      <typeparam name="TEventArg3">The third detailed event argument</typeparam>
    </member>
    <member name="E:W.EventTemplate`3.OnRaised">
      <summary>
            The template event
            </summary>
    </member>
    <member name="M:W.EventTemplate`3.Raise(System.Object,`0,`1,`2,System.String)">
      <summary>
            Raises the template event
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg1">The first detailed event argument</param>
      <param name="arg2">The second detailed event argument</param>
      <param name="arg3">The third detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="T:W.EventTemplate`4">
      <summary>
            Wraps the functionality of delegate, event and RaiseXXX into a single class
            </summary>
      <typeparam name="TEventArg1">The first detailed event argument</typeparam>
      <typeparam name="TEventArg2">The second detailed event argument</typeparam>
      <typeparam name="TEventArg3">The third detailed event argument</typeparam>
      <typeparam name="TEventArg4">The fourth detailed event argument</typeparam>
    </member>
    <member name="E:W.EventTemplate`4.OnRaised">
      <summary>
            The template event
            </summary>
    </member>
    <member name="M:W.EventTemplate`4.Raise(System.Object,`0,`1,`2,`3,System.String)">
      <summary>
            Raises the template event
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg1">The first detailed event argument</param>
      <param name="arg2">The second detailed event argument</param>
      <param name="arg3">The third detailed event argument</param>
      <param name="arg4">The fourth detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="T:W.EventTemplate`5">
      <summary>
            Wraps the functionality of delegate, event and RaiseXXX into a single class
            </summary>
      <typeparam name="TEventArg1">The first detailed event argument</typeparam>
      <typeparam name="TEventArg2">The second detailed event argument</typeparam>
      <typeparam name="TEventArg3">The third detailed event argument</typeparam>
      <typeparam name="TEventArg4">The fourth detailed event argument</typeparam>
      <typeparam name="TEventArg5">The fifth detailed event argument</typeparam>
    </member>
    <member name="E:W.EventTemplate`5.OnRaised">
      <summary>
            The template event
            </summary>
    </member>
    <member name="M:W.EventTemplate`5.Raise(System.Object,`0,`1,`2,`3,`4,System.String)">
      <summary>
            Raises the template event
            </summary>
      <param name="sender">The object which raised this event</param>
      <param name="arg1">The first detailed event argument</param>
      <param name="arg2">The second detailed event argument</param>
      <param name="arg3">The third detailed event argument</param>
      <param name="arg4">The fourth detailed event argument</param>
      <param name="arg5">The fifth detailed event argument</param>
      <param name="callerMemberName">The name of the method which raised the event</param>
    </member>
    <member name="T:W.AsExtensions.AsExtensions">
      <summary>
            Extensions which convert objects of one type to another
            </summary>
    </member>
    <member name="M:W.AsExtensions.AsExtensions.As``1(System.Object)">
      <summary>
            Use Generic syntax for the <bold>as</bold> operator.
            </summary>
      <typeparam name="TType">The type to convert the item reference to.</typeparam>
      <param name="this">The item to convert to type TType</param>
      <returns>Null if @this cannot be referenced as TType.  Otherwise, the item as TType</returns>
      <example>
        <code>expression as type</code> becomes <code>expression&lt;type&gt;()</code></example>
    </member>
    <member name="M:W.AsExtensions.AsExtensions.AsBase64(System.String)">
      <summary>
            Converts a string to Base64 encoding
            </summary>
      <param name="this">The string to convert to Base64 encoding</param>
      <returns>The Base64 encoded string</returns>
    </member>
    <member name="M:W.AsExtensions.AsExtensions.AsBase64(System.Byte[])">
      <summary>
            Converts a byte array to a Base64 encoded string
            </summary>
      <param name="this">The string to convert to Base64 encoding</param>
      <returns>The Base64 encoded string</returns>
    </member>
    <member name="M:W.AsExtensions.AsExtensions.AsBytes(System.String)">
      <summary>
            Converts a string to an encoded byte array
            </summary>
      <param name="this">The string to convert to an encoded byte array</param>
      <returns>A byte array encoding of the specified string</returns>
    </member>
    <member name="M:W.AsExtensions.AsExtensions.AsString(System.Byte[])">
      <summary>
            Converts an encoded byte array to a string
            </summary>
      <param name="this">The encoded byte array to conver to a string</param>
      <returns>The string representation of the encoded byte array</returns>
    </member>
    <member name="M:W.AsExtensions.AsExtensions.AsString(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Converts an encoded byte array to a string
            </summary>
      <param name="this">The encoded byte array to conver to a string</param>
      <param name="index">The starting index</param>
      <param name="count">The number of bytes to convert</param>
      <returns>The string representation of the encoded byte array</returns>
    </member>
    <member name="M:W.AsExtensions.AsExtensions.AsStream(System.Byte[])">
      <summary>
            Creates a MemoryStream object and initializes it with the specified byte array
            </summary>
      <param name="this">The byte array used in creating the MemoryStream</param>
      <returns>A new MemoryStream initialized with the specified byte array</returns>
    </member>
    <member name="M:W.AsExtensions.AsExtensions.AsStream(System.String)">
      <summary>
            Creates a MemoryStream object and initializes it with the specified string
            </summary>
      <param name="this">The string used in creating the MemoryStream</param>
      <returns>A new MemoryStream initilized with the specified string</returns>
    </member>
    <member name="M:W.AsExtensions.AsExtensions.AsJson``1(System.Object)">
      <summary>
            Serializes an object to a Json string
            </summary>
      <typeparam name="TType">The type of object to serialize</typeparam>
      <param name="this">The object to serialize to Json</param>
      <returns>A Json formatted string representation of the specified object</returns>
    </member>
    <member name="M:W.AsExtensions.AsExtensions.AsXml``1(System.Object)">
      <summary>
            Serializes an object to an xml string
            </summary>
      <typeparam name="TType">The type of object to serialize</typeparam>
      <param name="this">The object to serialize</param>
      <returns>A string containing the object as serialized into xml</returns>
    </member>
    <member name="M:W.AsExtensions.AsExtensions.AsCompressed(System.Byte[])">
      <summary>
            Compresses the byte array using System.IO.Compression.DeflateStream
            </summary>
      <param name="bytes">The byte array to compress</param>
      <returns>A byte array of compressed data</returns>
    </member>
    <member name="M:W.AsExtensions.AsExtensions.AsDecompressed(System.Byte[])">
      <summary>
            Decompresses the byte array using System.IO.Compression.DeflateStream
            </summary>
      <param name="bytes">The byte array containing compressed data</param>
      <returns>A byte array of the decompressed data</returns>
    </member>
    <member name="T:W.DelegateExtensions.DelegateExtensions">
      <summary>
            Extension methods for delegates
            </summary>
    </member>
    <member name="M:W.DelegateExtensions.DelegateExtensions.Raise(System.Delegate,System.Object[])">
      <summary>
            Calls the delegate, passing in any arguments.  Provides error handling to allow all subscribers to handle the delegate.
            </summary>
      <param name="del">The delegate to call</param>
      <param name="args">Parameters to pass into the delegate</param>
      <returns>Exceptions if any are thrown</returns>
    </member>
    <member name="T:W.FromExtensions.FromExtensions">
      <summary>
            Extensions which convert objects of one type to another
            </summary>
    </member>
    <member name="M:W.FromExtensions.FromExtensions.FromBase64(System.String)">
      <summary>
            Converts a Base64 encoded string back to a normal string
            </summary>
      <param name="this">The Base64 encoded string to convert</param>
      <returns>A non-encoded string</returns>
    </member>
    <member name="M:W.FromExtensions.FromExtensions.FromBase64(System.Byte[])">
      <summary>
            Converts a Base64 encoded byte array back to a normal byte array
            </summary>
      <param name="this">The Base64 encoded byte array to convert</param>
      <returns>A non-encoded string</returns>
    </member>
    <member name="M:W.FromExtensions.FromExtensions.FromJson``1(System.String)">
      <summary>
            Deserializes a Json string to an object
            </summary>
      <typeparam name="TType">The type of object to deserialize</typeparam>
      <param name="this">The Json formatted string</param>
      <returns>A new instance of TType deserialized from the specified Json string</returns>
    </member>
    <member name="M:W.FromExtensions.FromExtensions.FromJson``1(System.Byte[])">
      <summary>
            Deserializes an encoded byte array of Json to an object
            </summary>
      <typeparam name="TType">The type of object to deserialize</typeparam>
      <param name="this">The byte array containing encoded Json</param>
      <returns>A new instance of TType deserialized from the specified Json encoded byte array</returns>
    </member>
    <member name="M:W.FromExtensions.FromExtensions.FromXml``1(System.String)">
      <summary>
            Deserializes an Xml string to an object
            </summary>
      <typeparam name="TType">The type of object to deserialize</typeparam>
      <param name="this">The Json formatted string</param>
      <returns>A new instance of TType deserialized from the specified Xml string</returns>
    </member>
    <member name="M:W.FromExtensions.FromExtensions.FromXml``1(System.Byte[])">
      <summary>
            Deserializes an Xml string to an object
            </summary>
      <typeparam name="TType">The type of object to deserialize</typeparam>
      <param name="this">The Xml formatted string</param>
      <returns>A new instace of TType deserialized from the specified Xml string</returns>
    </member>
    <member name="M:W.FromExtensions.FromExtensions.FromCompressed(System.Byte[])">
      <summary>
            Decompresses the byte array using System.IO.Compression.DeflateStream
            </summary>
      <param name="bytes">The byte array containing compressed data</param>
      <returns>A byte array of the decompressed data</returns>
    </member>
    <member name="T:W.Threading.GateExtensions.GateExtensions">
      <summary>
            Extension methods on Action to Create a Gate
            </summary>
    </member>
    <member name="M:W.Threading.GateExtensions.GateExtensions.AsGate(System.Action{System.Threading.CancellationToken})">
      <summary>
            Creates a Gate with the supplied action
            </summary>
      <param name="action">The Action to call when the gate is relased (when Run is called)</param>
      <returns>A reference to a new Gate</returns>
    </member>
    <member name="M:W.Threading.GateExtensions.GateExtensions.AsGate``1(System.Action{``0,System.Threading.CancellationToken})">
      <summary>
            Creates a Gate with the supplied action
            </summary>
      <typeparam name="TParameterType">The Type of the parameter to be passed in</typeparam>
      <param name="action">The Action to call when the gate is released (when Run is called)</param>
      <returns>A reference to a new Gate</returns>
    </member>
    <member name="T:W.Threading.ThreadExtensions.ThreadExtensions">
      <summary>
            Extension methods related to threading
            </summary>
    </member>
    <member name="T:W.Threading.CPUProfileEnum">
      <summary>
            The preferred level of CPU usage
            </summary>
    </member>
    <member name="F:W.Threading.CPUProfileEnum.SpinWait0">
      <summary>High CPU usage, but fastest execution.  May be faster on single-core/cpu machines.  May be slower on multi-core/cpu machines.</summary>
    </member>
    <member name="F:W.Threading.CPUProfileEnum.Sleep">
      <summary>Medium CPU usage.  Uses Thread.Sleep or Task.Delay to block the current thread.</summary>
    </member>
    <member name="F:W.Threading.CPUProfileEnum.SpinWait1">
      <summary>Low CPU usage.  Should be faster on multi-core/cpu machines as the load will be divided among cores/cpus.  Slowest on single-core/cpu machines.</summary>
    </member>
    <member name="F:W.Threading.CPUProfileEnum.Yield">
      <summary>Only available for .Net Framework; uses Thread.Yield instead of Thread.Sleep.</summary>
    </member>
    <member name="T:W.Threading.Gate`1">
      <summary>
            A thread Gate which supports passing in a typed parameter
            </summary>
      <typeparam name="TParameterType">The type of parameter that will be passed to the gated thread procedure</typeparam>
    </member>
    <member name="M:W.Threading.Gate`1.CallAction(System.Threading.CancellationToken)">
      <summary>
            Invokes the gated Action
            </summary>
      <param name="token">The CancellationToken which is passed into the Action and should be used to monitor whether the Gate has been cancelled</param>
    </member>
    <member name="M:W.Threading.Gate`1.Run">
      <summary>
            Opens the gate (allows the gated Action to be called), passing in the default value which was specified in the constructor
            </summary>
    </member>
    <member name="M:W.Threading.Gate`1.Run(`0)">
      <summary>
            Opens the gate (allows the gated Action to be called), passing in the specified typed value
            </summary>
      <param name="arg">The argument to pass into the gated Action</param>
    </member>
    <member name="M:W.Threading.Gate`1.#ctor(System.Action{`0,System.Threading.CancellationToken})">
      <summary>
            Constructs a new Gate
            </summary>
      <param name="action">The Action to call when the gate is opened</param>
    </member>
    <member name="M:W.Threading.Gate`1.#ctor(System.Action{`0,System.Threading.CancellationToken},`0)">
      <summary>
            Constructs a new Gate
            </summary>
      <param name="action">The Action to call when the gate is opened</param>
      <param name="defaultArg">A default value which will be passed to the gated Action, if not otherwise specified</param>
    </member>
    <member name="T:W.Threading.Gate">
      <summary>
            A thread Gate is a background thread which is initially closed.  When a Gate is opened, the Action runs until completion.  The Gate can be opened (Run) any number of times.
            </summary>
    </member>
    <member name="M:W.Threading.Gate.CallAction(System.Threading.CancellationToken)">
      <summary>
            Invokes the gated Action
            </summary>
      <param name="token">The CancellationToken which is passed into the Action and should be used to monitor whether the Gate has been cancelled</param>
    </member>
    <member name="P:W.Threading.Gate.IsRunning">
      <summary>
            True if the Gate is currently open (running), otherwise False
            </summary>
    </member>
    <member name="P:W.Threading.Gate.IsComplete">
      <summary>
            True if the gated Action has completed, otherwise False
            </summary>
    </member>
    <member name="M:W.Threading.Gate.Run">
      <summary>
            Signals the thread to open the gate (allows the gated Action to be called).
            </summary>
    </member>
    <member name="M:W.Threading.Gate.Join">
      <summary>
            Blocks the calling thread until the gated Action is complete
            </summary>
    </member>
    <member name="M:W.Threading.Gate.Join(System.Int32)">
      <summary>
            Blocks the calling thread until the gated Action is complete, or until the specified number of milliseconds has elapsed
            </summary>
      <param name="msTimeout">The number of milliseconds to wait for the gate to complete before timing out and returning False</param>
      <returns>True if the gate completed within the specified timeout, otherwise False</returns>
    </member>
    <member name="M:W.Threading.Gate.Cancel">
      <summary>
            Singals the gated Action that a Cancel has been requested
            </summary>
    </member>
    <member name="M:W.Threading.Gate.Dispose">
      <summary>
            Cancels the gated Action, disposes the Gate and releases resources
            </summary>
    </member>
    <member name="M:W.Threading.Gate.#ctor(System.Action{System.Threading.CancellationToken})">
      <summary>
            Constructs a new Gate
            </summary>
      <param name="action">The Action to call when the gate is opened</param>
    </member>
    <member name="T:W.Threading.Lockers.ILocker">
      <summary>
            The required implementation for a locking object
            </summary>
    </member>
    <member name="M:W.Threading.Lockers.ILocker.InLock(System.Action)">
      <summary>
            Perform some action in a lock
            </summary>
      <param name="action">The action to perform</param>
    </member>
    <member name="M:W.Threading.Lockers.ILocker.InLock``1(System.Func{``0})">
      <summary>
            Perform some function in a lock
            </summary>
      <typeparam name="TResult">The result Type</typeparam>
      <param name="func">The function to perform</param>
      <returns>The result of the function</returns>
    </member>
    <!-- Badly formed XML comment ignored for member "M:W.Threading.Lockers.ILocker.InLockAsync(System.Action)" -->
    <member name="M:W.Threading.Lockers.ILocker.InLockAsync``1(System.Func{``0})">
      <summary>
            Asyncrhonously perform some function in a lock
            </summary>
      <typeparam name="TResult">The result Type</typeparam>
      <param name="func">The function to perform</param>
      <returns>The result of the function</returns>
    </member>
    <member name="T:W.Threading.Lockers.ILocker`1">
      <summary>
            The required implementation for a locking object
            </summary>
      <typeparam name="TLocker">The type of locker to use (SpinLock, Monitor, SemaphoreSlim, ReaderWriterLock)</typeparam>
    </member>
    <member name="P:W.Threading.Lockers.ILocker`1.Locker">
      <summary>
            The object used for locking
            </summary>
    </member>
    <member name="T:W.Threading.Lockers.StateAssignmentDelegate`1">
      <summary>
            Delegate which can be used to assign a new value to the internal state
            </summary>
      <param name="state">The current state</param>
      <returns>The new value for the internal state</returns>
    </member>
    <member name="T:W.Threading.Lockers.IStateLocker`2">
      <summary>
            The required implementation for a stateful locking object
            </summary>
    </member>
    <member name="M:W.Threading.Lockers.IStateLocker`2.InLock(System.Action{`1})">
      <summary>
            Perform some action in a lock
            </summary>
      <param name="action">The action to perform</param>
    </member>
    <member name="M:W.Threading.Lockers.IStateLocker`2.InLock(System.Func{`1,`1})">
      <summary>
            Perform some function in a lock
            </summary>
      <param name="func">The function to perform</param>
      <returns>The result of the function</returns>
    </member>
    <!-- Badly formed XML comment ignored for member "M:W.Threading.Lockers.IStateLocker`2.InLockAsync(System.Action{`1})" -->
    <member name="M:W.Threading.Lockers.IStateLocker`2.InLockAsync(System.Func{`1,`1})">
      <summary>
            Asyncrhonously perform some function in a lock
            </summary>
      <typeparam name="TResult">The result Type</typeparam>
      <param name="func">The function to perform</param>
      <returns>The result of the function</returns>
    </member>
    <member name="T:W.Threading.Lockers.MonitorLocker">
      <summary>
            Uses Monitor to provide thread-safety
            </summary>
      <remarks>Can be overridden to provide additional functionality</remarks>
    </member>
    <member name="P:W.Threading.Lockers.MonitorLocker.Locker">
      <summary>
            The object used to perform locks
            </summary>
    </member>
    <member name="M:W.Threading.Lockers.MonitorLocker.InLock(System.Action)">
      <summary>
            Executes an action from within a Monitor
            </summary>
      <param name="action">The action to run</param>
    </member>
    <member name="M:W.Threading.Lockers.MonitorLocker.InLock``1(System.Func{``0})">
      <summary>
            Executes a function from within a Monitor
            </summary>
      <typeparam name="TValue">The type of return value</typeparam>
      <param name="func">The function to run</param>
      <returns>The result of the function call (a value of type TValue)</returns>
    </member>
    <member name="M:W.Threading.Lockers.MonitorLocker.InLockAsync(System.Action)">
      <summary>
            Executes an action from within a Monitor
            </summary>
      <param name="action">The action to run</param>
    </member>
    <member name="M:W.Threading.Lockers.MonitorLocker.InLockAsync``1(System.Func{``0})">
      <summary>
            Executes a function from within a Monitor
            </summary>
      <typeparam name="TValue">The type of return value</typeparam>
      <param name="func">The function to run</param>
      <returns>The result of the function call (a value of type TValue)</returns>
    </member>
    <member name="T:W.Threading.Lockers.MonitorLocker`1">
      <summary>
            Extends MonitorLocker with an internal state variable
            </summary>
      <typeparam name="TState">The state Type</typeparam>
      <remarks>Same as StateLocker&lt;MonitorLocker;, TState&gt;</remarks>
    </member>
    <member name="T:W.Threading.Lockers.LockTypeEnum">
      <summary>
            Used by ReaderWriterLocker to specify the type of lock to obtain
            </summary>
    </member>
    <member name="F:W.Threading.Lockers.LockTypeEnum.Read">
      <summary>
            Obtain a read-lock
            </summary>
    </member>
    <member name="F:W.Threading.Lockers.LockTypeEnum.Write">
      <summary>
            Obtain a write-lock
            </summary>
    </member>
    <member name="T:W.Threading.Lockers.ReaderWriterLocker">
      <summary>
            Uses ReaderWriterLockSlim to provide thread-safety
            </summary>
      <remarks>Can be overridden to provide additional functionality</remarks>
    </member>
    <member name="M:W.Threading.Lockers.ReaderWriterLocker.InLock(W.Threading.Lockers.LockTypeEnum,System.Action)">
      <summary>
            Executes an action from within a ReaderWriterLockSlim
            </summary>
      <param name="action">The action to run</param>
    </member>
    <member name="M:W.Threading.Lockers.ReaderWriterLocker.InLock``1(W.Threading.Lockers.LockTypeEnum,System.Func{``0})">
      <summary>
            Executes a function from within a ReaderWriterLockSlim
            </summary>
      <typeparam name="TValue">The type of return value</typeparam>
      <param name="func">The function to run</param>
      <returns>The result of the function call (a value of type TValue)</returns>
    </member>
    <member name="M:W.Threading.Lockers.ReaderWriterLocker.InLockAsync(W.Threading.Lockers.LockTypeEnum,System.Action)">
      <summary>
            Executes an action from within a ReaderWriterLockSlim
            </summary>
      <param name="action">The action to run</param>
    </member>
    <member name="M:W.Threading.Lockers.ReaderWriterLocker.InLockAsync``1(W.Threading.Lockers.LockTypeEnum,System.Func{``0})">
      <summary>
            Executes a function from within a ReaderWriterLockSlim
            </summary>
      <typeparam name="TValue">The type of return value</typeparam>
      <param name="func">The function to run</param>
      <returns>The result of the function call (a value of type TValue)</returns>
    </member>
    <member name="M:W.Threading.Lockers.ReaderWriterLocker.Dispose">
      <summary>
            Disposes the instance and releases resources
            </summary>
    </member>
    <member name="M:W.Threading.Lockers.ReaderWriterLocker.#ctor">
      <summary>
            Constructs a new ReaderWriterLocker with a LockRecursionPolicy of NoRecursion
            </summary>
    </member>
    <member name="M:W.Threading.Lockers.ReaderWriterLocker.#ctor(System.Threading.LockRecursionPolicy)">
      <summary>
            Constructs a new ReaderWriterLocker using the specified LockRecursionPolicy
            </summary>
      <param name="lockPolicy">The lock recusion policy to use</param>
    </member>
    <member name="P:W.Threading.Lockers.ReaderWriterLocker.Locker">
      <summary>
            The ReaderWriterLockSlim used to perform locks
            </summary>
    </member>
    <member name="M:W.Threading.Lockers.ReaderWriterLocker.InLock(System.Action)">
      <summary>
            Performs the action in a read lock
            </summary>
      <param name="action">The action to perform</param>
    </member>
    <member name="M:W.Threading.Lockers.ReaderWriterLocker.InLock``1(System.Func{``0})">
      <summary>
            Performs the function in a read lock
            </summary>
      <param name="func">The function to perform</param>
    </member>
    <member name="M:W.Threading.Lockers.ReaderWriterLocker.InLockAsync(System.Action)">
      <summary>
            Asynchronously performs the action in a read lock
            </summary>
      <param name="action">The action to perform</param>
    </member>
    <member name="M:W.Threading.Lockers.ReaderWriterLocker.InLockAsync``1(System.Func{``0})">
      <summary>
            Asynchronously performs the function in a read lock
            </summary>
      <param name="func">The action to perform</param>
    </member>
    <member name="T:W.Threading.Lockers.ReaderWriterLocker`1">
      <summary>
            Extends ReaderWriterLocker with an internal state variable
            </summary>
      <typeparam name="TState">The state Type</typeparam>
    </member>
    <member name="M:W.Threading.Lockers.ReaderWriterLocker`1.Dispose">
      <summary>
            Disposes this object and releases resources
            </summary>
    </member>
    <member name="M:W.Threading.Lockers.ReaderWriterLocker`1.InLock(W.Threading.Lockers.LockTypeEnum,System.Action{`0})">
      <summary>
            Performs the action in a lock, passing in the current state
            </summary>
      <param name="action">The action to perform</param>
    </member>
    <member name="M:W.Threading.Lockers.ReaderWriterLocker`1.InLock(W.Threading.Lockers.LockTypeEnum,System.Func{`0,`0})">
      <summary>
            Performs the function in a lock, passing in the current state
            </summary>
      <param name="func">The action to perform</param>
    </member>
    <member name="M:W.Threading.Lockers.ReaderWriterLocker`1.InLockAsync(W.Threading.Lockers.LockTypeEnum,System.Action{`0})">
      <summary>
            Asynchronously performs the action in a lock, passing in the current state
            </summary>
      <param name="action">The action to perform</param>
    </member>
    <member name="M:W.Threading.Lockers.ReaderWriterLocker`1.InLockAsync(W.Threading.Lockers.LockTypeEnum,System.Func{`0,`0})">
      <summary>
            Asynchronously performs the function in a lock, passing in the current state and assigning the state to the result
            </summary>
      <param name="func">The action to perform</param>
    </member>
    <member name="T:W.Threading.Lockers.SemaphoreSlimLocker">
      <summary>
            Uses SemaphoreSlim to provide locking
            </summary>
    </member>
    <member name="P:W.Threading.Lockers.SemaphoreSlimLocker.Locker">
      <summary>
            The SemaphoreSlim used to perform locks
            </summary>
    </member>
    <member name="M:W.Threading.Lockers.SemaphoreSlimLocker.InLock(System.Action)">
      <summary>
            Executes an action from within a SemaphoreSlim
            </summary>
      <param name="action">The action to run</param>
    </member>
    <member name="M:W.Threading.Lockers.SemaphoreSlimLocker.InLock``1(System.Func{``0})">
      <summary>
            Executes a function from within a SemaphoreSlim
            </summary>
      <typeparam name="TValue">The type of return value</typeparam>
      <param name="func">The function to run</param>
      <returns>The result of the function call (a value of type TValue)</returns>
    </member>
    <member name="M:W.Threading.Lockers.SemaphoreSlimLocker.InLockAsync(System.Action)">
      <summary>
            Executes an action from within a SemaphoreSlim
            </summary>
      <param name="action">The action to run</param>
    </member>
    <member name="M:W.Threading.Lockers.SemaphoreSlimLocker.InLockAsync``1(System.Func{``0})">
      <summary>
            Executes a function from within a SemaphoreSlim
            </summary>
      <typeparam name="TValue">The type of return value</typeparam>
      <param name="func">The function to run</param>
      <returns>The result of the function call (a value of type TValue)</returns>
    </member>
    <member name="M:W.Threading.Lockers.SemaphoreSlimLocker.Dispose">
      <summary>
            Disposes the SemaphoreSlimLocker and releases resources
            </summary>
    </member>
    <member name="M:W.Threading.Lockers.SemaphoreSlimLocker.#ctor">
      <summary>
            Constructs a new SemaphoreSlimLocker with an initial request count of 1 and maximum request count of 1
            </summary>
    </member>
    <member name="M:W.Threading.Lockers.SemaphoreSlimLocker.#ctor(System.Int32)">
      <summary>
            Constructs a new SemaphoreSlimLocker
            </summary>
      <param name="initialCount">The initial number of requests that the semaphore can grant concurrently</param>
    </member>
    <member name="M:W.Threading.Lockers.SemaphoreSlimLocker.#ctor(System.Int32,System.Int32)">
      <summary>
            Constructs a new SemaphoreSlimLocker
            </summary>
      <param name="initialCount">The initial number of requests that the semaphore can grant concurrently</param>
      <param name="maxCount">The maximum number of requests that can be granted concurrently</param>
    </member>
    <member name="T:W.Threading.Lockers.SemaphoreSlimLocker`1">
      <summary>
            Extends SemaphoreSlimLocker with an internal state variable
            </summary>
      <typeparam name="TState">The state Type</typeparam>
      <remarks>Same as StateLocker&lt;SemaphoreSlimLocker;, TState&gt;</remarks>
    </member>
    <member name="T:W.Threading.Lockers.SpinLocker">
      <summary>
            Uses SpinLock to provide thread-safety
            </summary>
      <remarks>Can be overridden to provide additional functionality</remarks>
    </member>
    <member name="P:W.Threading.Lockers.SpinLocker.Locker">
      <summary>
            The SpinLock used to perform locks
            </summary>
    </member>
    <member name="M:W.Threading.Lockers.SpinLocker.InLock(System.Action)">
      <summary>
            Performs an action from within a SpinLock
            </summary>
      <param name="action">The action to run</param>
    </member>
    <member name="M:W.Threading.Lockers.SpinLocker.InLock``1(System.Func{``0})">
      <summary>
            Performs a function from within a SpinLock
            </summary>
      <typeparam name="TResult">The type of return value</typeparam>
      <param name="func">The function to run</param>
      <returns>The result of the function call (a value of type TValue)</returns>
    </member>
    <member name="M:W.Threading.Lockers.SpinLocker.InLockAsync(System.Action)">
      <summary>
            Performs an action from within a SpinLock
            </summary>
      <param name="action">The action to run</param>
    </member>
    <member name="M:W.Threading.Lockers.SpinLocker.InLockAsync``1(System.Func{``0})">
      <summary>
            Performs a function from within a SpinLock
            </summary>
      <typeparam name="TResult">The type of return value</typeparam>
      <param name="func">The function to run</param>
      <returns>The result of the function call (a value of type TValue)</returns>
    </member>
    <member name="T:W.Threading.Lockers.SpinLocker`1">
      <summary>
            Extends SpinLocker with an internal state variable
            </summary>
      <typeparam name="TState">The state Type</typeparam>
      <remarks>Same as StateLocker&lt;SpinLocker;, TState&gt;</remarks>
    </member>
    <member name="T:W.Threading.Lockers.StateLocker`2">
      <summary>
            Extends a locker (SpinLocker, MonitorLocker, ReaderWriterLocker, SemaphoreSlimLocker) with an internal state value
            </summary>
      <typeparam name="TLocker">The Type of Locker to extend</typeparam>
      <typeparam name="TState">The Type of the internal state value</typeparam>
      <remarks>This class adds the state functionality by wrapping the TLocker and re-implementing the ILocker interface</remarks>
    </member>
    <member name="F:W.Threading.Lockers.StateLocker`2.State">
      <summary>
            The internal state
            </summary>
    </member>
    <member name="P:W.Threading.Lockers.StateLocker`2.Locker">
      <summary>
            The locking mechanism (SpinLock, Monitor, SemaphoreSlim, ReaderWriterLock)
            </summary>
    </member>
    <member name="M:W.Threading.Lockers.StateLocker`2.InLock(System.Action)">
      <summary>
            Performs an action from within a lock
            </summary>
      <param name="action">The action to run</param>
    </member>
    <member name="M:W.Threading.Lockers.StateLocker`2.InLock``1(System.Func{``0})">
      <summary>
            Performs a function from within a lock
            </summary>
      <param name="func">The function to run</param>
    </member>
    <member name="M:W.Threading.Lockers.StateLocker`2.InLockAsync(System.Action)">
      <summary>
            Asynchronously performs an action from within a lock
            </summary>
      <param name="action">The action to run</param>
    </member>
    <member name="M:W.Threading.Lockers.StateLocker`2.InLockAsync``1(System.Func{``0})">
      <summary>
            Asynchronously performs a function from within a lock
            </summary>
      <param name="func">The function to run</param>
    </member>
    <member name="M:W.Threading.Lockers.StateLocker`2.InLock(System.Action{`1})">
      <summary>
            Performs an action from within a lock, passing in the current state
            </summary>
      <param name="action">The action to run</param>
    </member>
    <member name="M:W.Threading.Lockers.StateLocker`2.InLock(System.Func{`1,`1})">
      <summary>
            Performs a function from within a lock, passing in the current state and assigning the state to the function result
            </summary>
      <param name="func">The function to run</param>
    </member>
    <member name="M:W.Threading.Lockers.StateLocker`2.InLockAsync(System.Action{`1})">
      <summary>
            Asynchronously performs an action from within a lock, passing in the current state
            </summary>
      <param name="func">The action to run</param>
    </member>
    <member name="M:W.Threading.Lockers.StateLocker`2.InLockAsync(System.Func{`1,`1})">
      <summary>
            Asynchronously performs a function from within a lock, passing in the current state and assigning the state to the function result
            </summary>
      <param name="func">The function to run</param>
    </member>
    <member name="T:W.Threading.GenericThreadDelegate">
      <summary>
            The delegate, with variable arguments, which is called on a separate thread
            </summary>
      <param name="token">The CancellationToken used to cancel the thread</param>
      <param name="args">The arguments to pass into the thread procedure</param>
    </member>
    <member name="T:W.Threading.ParameterizedThread">
      <summary>
            A thread class which supports a variable number of arguments
            </summary>
    </member>
    <member name="P:W.Threading.ParameterizedThread.Task">
      <summary>
            The underlying Task associated with this ParameterizedThread
            </summary>
    </member>
    <member name="M:W.Threading.ParameterizedThread.OnDispose">
      <summary>
            Dispose the thread and free resources
            </summary>
    </member>
    <member name="P:W.Threading.ParameterizedThread.IsStarted">
      <summary>
            True if the thread has been started, otherwise False
            </summary>
    </member>
    <member name="P:W.Threading.ParameterizedThread.IsComplete">
      <summary>
            True if the thread has completed, otherwise False
            </summary>
      <remarks>A True value does not indicate that the thread completed successfully</remarks>
    </member>
    <member name="P:W.Threading.ParameterizedThread.IsFaulted">
      <summary>
            True if the thread raised an exception, otherwise False
            </summary>
    </member>
    <member name="P:W.Threading.ParameterizedThread.Exception">
      <summary>
            The exception, if one was caught
            </summary>
    </member>
    <member name="P:W.Threading.ParameterizedThread.Token">
      <summary>
            Not available until after Start has been called
            </summary>
    </member>
    <member name="M:W.Threading.ParameterizedThread.Join">
      <summary>
            Block the calling thread until this thread object has completed
            </summary>
    </member>
    <member name="M:W.Threading.ParameterizedThread.Join(System.Int32)">
      <summary>
            Block the calling thread until this thread object has completed or until the timeout has occurred
            </summary>
      <param name="msTimeout">The number of milliseconds to wait, for the thread Action to complete, before timing out</param>
      <returns>True if the thread Action completed within the specified timeout, otherwise False</returns>
    </member>
    <member name="M:W.Threading.ParameterizedThread.Start(System.Object[])">
      <summary>
            Start the thread
            </summary>
    </member>
    <member name="M:W.Threading.ParameterizedThread.Start(System.Int32,System.Object[])">
      <summary>
            Start the thread with a CancellationToken which will timeout in the specified milliseconds
            </summary>
      <param name="msLifetime">The number of milliseconds before the thread is automatically cancelled. A negative value indicates an infinite lifetime.</param>
      <param name="args">The arguments to pass into the thread procedure</param>
    </member>
    <member name="M:W.Threading.ParameterizedThread.Stop">
      <summary>
            Stop the thread.  This calls Cancel on the CancellationToken
            </summary>
    </member>
    <member name="M:W.Threading.ParameterizedThread.#ctor(W.Threading.GenericThreadDelegate)">
      <summary>
            Constructs a new ParameterizedThread
            </summary>
      <param name="action">The action to call on a thread</param>
    </member>
    <member name="M:W.Threading.ParameterizedThread.Create(W.Threading.GenericThreadDelegate)">
      <summary>
            Starts a new ParameterizedThread
            </summary>
      <param name="action">Action to call on a thread</param>
      <returns>A new Thread</returns>
    </member>
    <member name="T:W.Threading.Thread">
      <summary>
            A thread class
            </summary>
    </member>
    <member name="M:W.Threading.Thread.Dispose">
      <summary>
            Disposes the Thread and releases resources
            </summary>
    </member>
    <member name="M:W.Threading.Thread.#ctor(System.Action{System.Threading.CancellationToken})">
      <summary>
            Constructs a new ThreadSlim using an Action&lt;CancellationToken&gt; as the thread method
            </summary>
      <param name="action">The action to run on a separate thread</param>
    </member>
    <member name="M:W.Threading.Thread.#ctor(W.Threading.ThreadDelegate)">
      <summary>
            Constructs a new ThreadSlim using a ThreadDelegate as the thread method
            </summary>
      <param name="delegate">The ThreadDelegate to run on a separate thread</param>
    </member>
    <member name="M:W.Threading.Thread.Sleep(System.Int32)">
      <summary>
            Blocks the calling thread for the specified time
            </summary>
      <param name="msDelay">The number of milliseconds to block the thread</param>
    </member>
    <member name="M:W.Threading.Thread.Sleep(System.Int32,System.Boolean)">
      <summary>
            Blocks the calling thread for the specified time
            </summary>
      <param name="msDelay">The number of milliseconds to block the thread</param>
      <param name="useSpinWait">If True, a SpinWait.SpinUntil will be used instead of a call to Thread.Sleep (or Task.Delay).  Note that SpinWait should only be used on multi-core/cpu machines.</param>
    </member>
    <member name="M:W.Threading.Thread.Sleep(W.Threading.CPUProfileEnum)">
      <summary>
            Attempts to free the CPU for other processes, based on the desired level.  Consequences will vary depending on your hardware architecture.  The more processors/cores you have, the better performance you will have by selecting LowCPU.  Likewise, on a single-core processor, you may wish to select HighCPU.
            </summary>
      <param name="level">The desired level of CPU usage</param>
      <remarks>Note results may vary.  LowCPU will spread the load onto multiple cores and can actually yield faster results depending on your hardware architecture.  This may not always be the case.</remarks>
    </member>
    <member name="M:W.Threading.Thread.Sleep(W.Threading.CPUProfileEnum,System.Int32)">
      <summary>
            Attempts to free the CPU for other processes, based on the desired level.  Consequences will vary depending on your hardware architecture.  The more processors/cores you have, the better performance you will have by selecting SpinWait1.  Likewise, on a single-core processor, you may wish to select SpinWait0.
            </summary>
      <param name="level">The desired level of CPU usage</param>
      <param name="msTimeout">Optional value for CPUProfileEnum.Sleep and CPUProfileEnum.SpinUntil. Ignored by other profiles.</param>
      <remarks>Note results may vary.  SpinWait1 will spread the load onto multiple cores and can actually yield faster results depending on your hardware architecture.  This may not always be the case.</remarks>
    </member>
    <member name="T:W.Threading.Thread`1">
      <summary>
            A thread class which can pass a typed parameter into the thread method
            </summary>
      <typeparam name="TType">The argument Type to be passed into the thread method</typeparam>
    </member>
    <member name="M:W.Threading.Thread`1.StartAsync(`0)">
      <summary>
            Starts the thread and returns the Task associated with it 
            </summary>
      <param name="arg">The argument to pass into the thread procedure</param>
      <returns>
      </returns>
    </member>
    <member name="M:W.Threading.Thread`1.#ctor(System.Action{System.Threading.CancellationToken,`0})">
      <summary>
            Constructs a new Thread which can accept a single, typed, paramter
            </summary>
      <param name="action">The action to run on a separate thread</param>
    </member>
    <member name="T:W.Threading.AnyMethodDelegate">
      <summary>
            The delegate Type used by ThreadMethod
            </summary>
      <param name="args">
      </param>
    </member>
    <member name="T:W.Threading.ThreadMethod">
      <summary>
            Adds multi-threading and additional functionality to an Action or ThreadMethodDelegate
            </summary>
    </member>
    <member name="P:W.Threading.ThreadMethod.Name">
      <summary>
            A user-defined name for this object
            </summary>
    </member>
    <member name="P:W.Threading.ThreadMethod.IsStarted">
      <summary>
            True if the method is running or has completed
            </summary>
    </member>
    <member name="P:W.Threading.ThreadMethod.IsRunning">
      <summary>
            True if the method is currently running and not complete, otherwise False
            </summary>
    </member>
    <member name="P:W.Threading.ThreadMethod.IsComplete">
      <summary>
            True if the method has completed, otherwise False
            </summary>
    </member>
    <member name="M:W.Threading.ThreadMethod.Initialize">
      <summary>
            Initializes variables and creates the task associated with this ThreadMethod
            </summary>
    </member>
    <member name="M:W.Threading.ThreadMethod.RunSynchronously(System.Object[])">
      <summary>
            Synchronously runs the method
            </summary>
      <param name="args">Arguments to pass into the thread method</param>
    </member>
    <member name="M:W.Threading.ThreadMethod.Start(System.Object[])">
      <summary>
            Asynchronously runs the method
            </summary>
      <param name="args">Arguments to pass into the thread method</param>
      <returns>The Task associated with the thread</returns>
    </member>
    <member name="M:W.Threading.ThreadMethod.StartAsync(System.Object[])">
      <summary>
            Asynchronously runs the method
            </summary>
      <param name="args">Arguments to pass into the thread method</param>
      <returns>The Task associated with the thread</returns>
    </member>
    <member name="M:W.Threading.ThreadMethod.Wait">
      <summary>
            Waits for the thread method to complete
            </summary>
    </member>
    <member name="M:W.Threading.ThreadMethod.Wait(System.Int32)">
      <summary>
            Waits for the thread method to complete
            </summary>
      <param name="msTimeout">The maximum number of milliseconds to wait for the thread to method complete</param>
      <returns>True if the thread method completes within the timeout period, otherwise False</returns>
    </member>
    <member name="M:W.Threading.ThreadMethod.Wait(System.Threading.CancellationToken)">
      <summary>
            Waits for the thread method to complete
            </summary>
      <param name="token">The CancellationToken to observe while waiting</param>
      <returns>True if the thread method completes before the CancellationToken is cancelled, otherwise False</returns>
    </member>
    <member name="M:W.Threading.ThreadMethod.Dispose">
      <summary>
            Disposes the ThreadMethod and releases resources
            </summary>
    </member>
    <member name="M:W.Threading.ThreadMethod.#ctor(W.Threading.AnyMethodDelegate)">
      <summary>
            Construct a new ThreadMethod
            </summary>
      <param name="delegate">The ThreadMethodDelegate to call on a thread</param>
    </member>
    <member name="M:W.Threading.ThreadMethod.Finalize">
      <summary>
            Destructs the ThreadMethod and releases resources
            </summary>
    </member>
    <member name="M:W.Threading.ThreadMethod.Create(W.Threading.AnyMethodDelegate)">
      <summary>
            Creates a new ThreadMethod from the ThreadMethodDelegate
            </summary>
      <param name="delegate">The ThreadMethodDelegate to wrap with an ThreadMethod</param>
      <returns>A new instance of an ThreadMethod</returns>
    </member>
    <member name="M:W.Threading.ThreadMethod.Create(System.Action)">
      <summary>
            Creates a new ThreadMethod from the Action
            </summary>
      <param name="action">The Action to wrap with an ThreadMethod</param>
      <returns>A new instance of an ThreadMethod</returns>
    </member>
    <member name="M:W.Threading.ThreadMethod.Create``1(System.Action{``0})">
      <summary>
            Creates a new ThreadMethod from the Action
            </summary>
      <param name="action">The Action to wrap with an ThreadMethod</param>
      <returns>A new instance of an ThreadMethod</returns>
    </member>
    <member name="M:W.Threading.ThreadMethod.Create``2(System.Action{``0,``1})">
      <summary>
            Creates a new ThreadMethod from the Action
            </summary>
      <param name="action">The Action to wrap with an ThreadMethod</param>
      <returns>A new instance of an ThreadMethod</returns>
    </member>
    <member name="M:W.Threading.ThreadMethod.Create``3(System.Action{``0,``1,``2})">
      <summary>
            Creates a new ThreadMethod from the Action
            </summary>
      <param name="action">The Action to wrap with an ThreadMethod</param>
      <returns>A new instance of an ThreadMethod</returns>
    </member>
    <member name="M:W.Threading.ThreadMethod.Create``4(System.Action{``0,``1,``2,``3})">
      <summary>
            Creates a new ThreadMethod from the Action
            </summary>
      <param name="action">The Action to wrap with an ThreadMethod</param>
      <returns>A new instance of an ThreadMethod</returns>
    </member>
    <member name="M:W.Threading.ThreadMethod.Create``5(System.Action{``0,``1,``2,``3,``4})">
      <summary>
            Creates a new ThreadMethod from the Action
            </summary>
      <param name="action">The Action to wrap with an ThreadMethod</param>
      <returns>A new instance of an ThreadMethod</returns>
    </member>
    <member name="T:W.Threading.ThreadDelegate">
      <summary>
            Thread delegate used by ThreadSlim
            </summary>
      <param name="token">A CancellationToken which can be used to signal the threaded method to stop</param>
      <param name="args">Arguments to pass into the thread method</param>
    </member>
    <member name="T:W.Threading.ThreadSlim">
      <summary>
            A lighter thread class than W.Threading.Thread
            </summary>
    </member>
    <member name="P:W.Threading.ThreadSlim.Name">
      <summary>
            A user-defined name for this object
            </summary>
    </member>
    <member name="P:W.Threading.ThreadSlim.IsStarted">
      <summary>
            True if the thread  is running or has completed
            </summary>
    </member>
    <member name="P:W.Threading.ThreadSlim.IsRunning">
      <summary>
            True if the thread is currently running and not complete, otherwise False
            </summary>
    </member>
    <member name="P:W.Threading.ThreadSlim.IsComplete">
      <summary>
            True if the thread has completed, otherwise False
            </summary>
    </member>
    <member name="M:W.Threading.ThreadSlim.SignalToStop">
      <summary>
            Signals the thread method to stop running
            </summary>
    </member>
    <member name="M:W.Threading.ThreadSlim.Stop">
      <summary>
            Signals the thread method to stop running and waits for it to complete
            </summary>
    </member>
    <member name="M:W.Threading.ThreadSlim.Stop(System.Int32)">
      <summary>
            Signals the thread method to stop running and waits the specified number of milliseconds for it to complete before returning
            </summary>
      <param name="msTimeout">The number of milliseconds to wait for the thread method to comlete</param>
      <returns>True if the thread method completes within the specified number of milliseconds, otherwise False</returns>
    </member>
    <member name="M:W.Threading.ThreadSlim.Stop(System.Threading.CancellationToken)">
      <summary>
            Signals the thread method to stop running and waits for the method to complete, while observing the specified CancellationToken
            </summary>
      <param name="token">The CancellationToken to observe while waiting</param>
      <returns>True if the thread method completes before the CancellationToken cancels, otherwise False</returns>
    </member>
    <member name="M:W.Threading.ThreadSlim.Start(System.Object[])">
      <summary>
            Starts the thread and waits for it to complete
            </summary>
      <param name="args">The arguments to pass into the thread procedure</param>
    </member>
    <member name="M:W.Threading.ThreadSlim.StartAsync(System.Object[])">
      <summary>
            Starts the thread and returns the Task associated with it 
            </summary>
      <param name="args">The arguments to pass into the thread procedure</param>
      <returns>
      </returns>
    </member>
    <member name="M:W.Threading.ThreadSlim.Wait">
      <summary>
            Wait for the thread to complete
            </summary>
    </member>
    <member name="M:W.Threading.ThreadSlim.Wait(System.Int32)">
      <summary>
            Wait for the thread to complete
            </summary>
      <param name="msTimeout">The amount of milliseconds to wait for the thread to complete</param>
      <returns>True if the thread completes within the specified timeout period, otherwise False</returns>
    </member>
    <member name="M:W.Threading.ThreadSlim.Wait(System.Threading.CancellationToken)">
      <summary>
            Wait for the thread to complete
            </summary>
      <param name="token">A CancellationToken to observe while waiting</param>
      <returns>True if the thread completed before the CancellationToken was canceled, otherwise FAlse</returns>
    </member>
    <member name="M:W.Threading.ThreadSlim.#ctor(W.Threading.ThreadDelegate)">
      <summary>
            Constructs a new ThreadSlim object
            </summary>
      <param name="delegate">The ThreadDelegate to run on a separate thread</param>
    </member>
    <member name="M:W.Threading.ThreadSlim.#ctor(System.Action{System.Threading.CancellationToken})">
      <summary>
            Constructs a new ThreadSlim using an Action&lt;CancellationToken&gt; as the thread method
            </summary>
      <param name="action">The action to run on a separate thread</param>
    </member>
    <member name="M:W.Threading.ThreadSlim.Create(W.Threading.ThreadDelegate)">
      <summary>
            Constructs a new ThreadSlim using an Action&lt;CancellationToken&gt; as the thread method
            </summary>
      <param name="delegate">The delegate to run on a seprate thread</param>
      <returns>
      </returns>
    </member>
    <member name="M:W.Threading.ThreadSlim.Create(System.Action{System.Threading.CancellationToken})">
      <summary>
            Constructs a new ThreadSlim using an Action&lt;CancellationToken&gt; as the thread method
            </summary>
      <param name="action">The action to run on a separate thread</param>
    </member>
    <member name="M:W.Threading.ThreadSlim.Create``1(System.Action{System.Threading.CancellationToken,``0})">
      <summary>
            Constructs a new ThreadSlim using an Action&lt;CancellationToken&gt; as the thread method
            </summary>
      <typeparam name="TArg">The Type of the argument to be passed into the thread method</typeparam>
      <param name="action">The action to run on a separate thread</param>
    </member>
    <member name="M:W.Threading.ThreadSlim.Create``2(System.Action{System.Threading.CancellationToken,``0,``1})">
      <summary>
            Constructs a new ThreadSlim using an Action&lt;CancellationToken&gt; as the thread method
            </summary>
      <typeparam name="TArg1">The Type of the first argument to be passed into the thread method</typeparam>
      <typeparam name="TArg2">The Type of the second argument to be passed into the thread method</typeparam>
      <param name="action">The action to run on a separate thread</param>
    </member>
    <member name="M:W.Threading.ThreadSlim.Create``3(System.Action{System.Threading.CancellationToken,``0,``1,``2})">
      <summary>
            Constructs a new ThreadSlim using an Action&lt;CancellationToken&gt; as the thread method
            </summary>
      <typeparam name="TArg1">The Type of the first argument to be passed into the thread method</typeparam>
      <typeparam name="TArg2">The Type of the second argument to be passed into the thread method</typeparam>
      <typeparam name="TArg3">The Type of the third argument to be passed into the thread method</typeparam>
      <param name="action">The action to run on a separate thread</param>
    </member>
    <member name="M:W.Threading.ThreadSlim.Create``4(System.Action{System.Threading.CancellationToken,``0,``1,``2,``3})">
      <summary>
            Constructs a new ThreadSlim using an Action&lt;CancellationToken&gt; as the thread method
            </summary>
      <typeparam name="TArg1">The Type of the first argument to be passed into the thread method</typeparam>
      <typeparam name="TArg2">The Type of the second argument to be passed into the thread method</typeparam>
      <typeparam name="TArg3">The Type of the third argument to be passed into the thread method</typeparam>
      <typeparam name="TArg4">The Type of the fourth argument to be passed into the thread method</typeparam>
      <param name="action">The action to run on a separate thread</param>
    </member>
    <member name="M:W.Threading.ThreadSlim.Create``5(System.Action{System.Threading.CancellationToken,``0,``1,``2,``3,``4})">
      <summary>
            Constructs a new ThreadSlim using an Action&lt;CancellationToken&gt; as the thread method
            </summary>
      <typeparam name="TArg1">The Type of the first argument to be passed into the thread method</typeparam>
      <typeparam name="TArg2">The Type of the second argument to be passed into the thread method</typeparam>
      <typeparam name="TArg3">The Type of the third argument to be passed into the thread method</typeparam>
      <typeparam name="TArg4">The Type of the fourth argument to be passed into the thread method</typeparam>
      <typeparam name="TArg5">The Type of the fifth argument to be passed into the thread method</typeparam>
      <param name="action">The action to run on a separate thread</param>
    </member>
    <member name="T:W.InvokeExtensions.InvokeExtensions">
      <summary>
            Extensions to provide code shortcuts to evaluate InvokeRequired and run code appropriately
            </summary>
    </member>
    <member name="M:W.InvokeExtensions.InvokeExtensions.InvokeEx``1(``0,System.Action{``0})">
      <summary>
            Runs the provided Action on the UI thread
            </summary>
      <param name="this">The form or control which supports ISynchronizeInvoke</param>
      <param name="action">The code to be executed on the UI thread</param>
      <typeparam name="T">The form or control who's thread will execute the code</typeparam>
    </member>
    <member name="M:W.InvokeExtensions.InvokeExtensions.InvokeEx``2(``0,System.Func{``0,``1})">
      <summary>
            Runs the provided Function on the UI thread. Avoids the cross-threaded exceptions.
            </summary>
      <param name="this">The form or control which supports ISynchronizationInvoke</param>
      <param name="f">The function to be executed on the UI thread</param>
      <typeparam name="T">The form or control who's thread will execute the code</typeparam>
      <typeparam name="U">The type of return value</typeparam>
      <returns>The function should return an object of type U</returns>
    </member>
    <member name="M:W.InvokeExtensions.InvokeExtensions.InvokeEx``1(``0,System.Func{``0,System.Object})">
      <summary>
            Runs the provided Function on the UI thread. Avoids the cross-threaded exceptions.
            </summary>
      <param name="this">The form or control which supports ISynchronizationInvoke</param>
      <param name="f">The function to be executed on the UI thread</param>
      <typeparam name="T">The form or control who's thread will execute the code</typeparam>
      <returns>The function should return an object</returns>
    </member>
    <member name="T:W.LockExtensions.SemaphoreSlimExtensions">
      <summary>
            Extensions to simplify locking with SemaphoreSlim
            </summary>
    </member>
    <member name="M:W.LockExtensions.SemaphoreSlimExtensions.InLock(System.Threading.SemaphoreSlim,System.Action)">
      <summary>
            Performs the action in a lock
            </summary>
      <param name="this">The SemaphoreSlim to provide resource locking</param>
      <param name="action">The action to perform</param>
    </member>
    <member name="M:W.LockExtensions.SemaphoreSlimExtensions.InLockAsync(System.Threading.SemaphoreSlim,System.Action)">
      <summary>
            Asynchronously performs the action in a lock
            </summary>
      <param name="this">The SemaphoreSlim to provide resource locking</param>
      <param name="action">The action to perform</param>
    </member>
    <member name="M:W.LockExtensions.SemaphoreSlimExtensions.InLock``1(System.Threading.SemaphoreSlim,System.Func{``0})">
      <summary>
            Performs the action in a lock
            </summary>
      <param name="this">The SemaphoreSlim to provide resource locking</param>
      <param name="func">The function to perform</param>
    </member>
    <member name="M:W.LockExtensions.SemaphoreSlimExtensions.InLockAsync``1(System.Threading.SemaphoreSlim,System.Func{``0})">
      <summary>
            Asynchronously performs the function in a lock
            </summary>
      <param name="this">The SemaphoreSlim to provide resource locking</param>
      <param name="func">The function to perform</param>
    </member>
    <member name="T:W.LockExtensions.SpinLockExtensions">
      <summary>
            Extensions to simplify locking with SpinLock
            </summary>
    </member>
    <member name="M:W.LockExtensions.SpinLockExtensions.InLock(System.Threading.SpinLock,System.Action)">
      <summary>
            Performs the action in a lock
            </summary>
      <param name="this">The SpinLock to provide resource locking</param>
      <param name="action">The action to perform</param>
    </member>
    <member name="M:W.LockExtensions.SpinLockExtensions.InLockAsync(System.Threading.SpinLock,System.Action)">
      <summary>
            Asynchronously performs the action in a lock
            </summary>
      <param name="this">The SpinLock to provide resource locking</param>
      <param name="action">The action to perform</param>
    </member>
    <member name="M:W.LockExtensions.SpinLockExtensions.InLock``1(System.Threading.SpinLock,System.Func{``0})">
      <summary>
            Performs the function in a lock
            </summary>
      <param name="this">The SpinLock to provide resource locking</param>
      <param name="func">The function to perform</param>
    </member>
    <member name="M:W.LockExtensions.SpinLockExtensions.InLockAsync``1(System.Threading.SpinLock,System.Func{``0})">
      <summary>
            Asynchronously performs the function in a lock
            </summary>
      <param name="this">The SpinLock to provide resource locking</param>
      <param name="func">The function to perform</param>
    </member>
    <member name="T:W.LockExtensions.MonitorExtensions">
      <summary>
            Extensions to object to simplify locking with Monitor
            </summary>
    </member>
    <member name="M:W.LockExtensions.MonitorExtensions.InLock(System.Object,System.Action)">
      <summary>
            Performs the action in a Monitor lock
            </summary>
      <param name="this">The object to provide resource locking</param>
      <param name="action">The action to perform</param>
    </member>
    <member name="M:W.LockExtensions.MonitorExtensions.InLockAsync(System.Object,System.Action)">
      <summary>
            Asynchronously performs the action in a Monitor lock
            </summary>
      <param name="this">The object to provide resource locking</param>
      <param name="action">The action to perform</param>
    </member>
    <member name="M:W.LockExtensions.MonitorExtensions.InLock``1(System.Object,System.Func{``0})">
      <summary>
            Performs the function in a Monitor lock
            </summary>
      <param name="this">The object to provide resource locking</param>
      <param name="func">The function to perform</param>
    </member>
    <member name="M:W.LockExtensions.MonitorExtensions.InLockAsync``1(System.Object,System.Func{``0})">
      <summary>
            Asynchronously performs the action in a Monitor lock
            </summary>
      <param name="this">The object to provide resource locking</param>
      <param name="func">The function to perform</param>
    </member>
    <member name="T:W.LockExtensions.ReaderWriterLockSlimExtensions">
      <summary>
            Extensions to simplify locking with ReaderWriterLockSlim
            </summary>
    </member>
    <member name="M:W.LockExtensions.ReaderWriterLockSlimExtensions.Lock(System.Threading.ReaderWriterLockSlim,W.Threading.Lockers.LockTypeEnum)">
      <summary>
            Enters a read or write lock on the ReaderWriterLockSlim
            </summary>
      <param name="this">The object to provide resource locking</param>
      <param name="lockType">The type of lock to enter</param>
    </member>
    <member name="M:W.LockExtensions.ReaderWriterLockSlimExtensions.Unlock(System.Threading.ReaderWriterLockSlim,W.Threading.Lockers.LockTypeEnum)">
      <summary>
            Exits a read or write lock on the ReaderWriterLockSlim
            </summary>
      <param name="this">The object to provide resource locking</param>
      <param name="lockType">The type of lock to exit</param>
    </member>
    <member name="M:W.LockExtensions.ReaderWriterLockSlimExtensions.InLock(System.Threading.ReaderWriterLockSlim,W.Threading.Lockers.LockTypeEnum,System.Action)">
      <summary>
            Performs the action in a lock
            </summary>
      <param name="this">The ReaderWriterLockSlim to provide resource locking</param>
      <param name="lockType">The type of lock to obtain</param>
      <param name="action">The action to perform</param>
    </member>
    <member name="M:W.LockExtensions.ReaderWriterLockSlimExtensions.InLockAsync(System.Threading.ReaderWriterLockSlim,W.Threading.Lockers.LockTypeEnum,System.Action)">
      <summary>
            Asynchronously performs the action in a lock
            </summary>
      <param name="this">The ReaderWriterLockSlim to provide resource locking</param>
      <param name="lockType">The type of lock to obtain</param>
      <param name="action">The action to perform</param>
    </member>
    <member name="M:W.LockExtensions.ReaderWriterLockSlimExtensions.InLock``1(System.Threading.ReaderWriterLockSlim,W.Threading.Lockers.LockTypeEnum,System.Func{``0})">
      <summary>
            Performs the function in a lock
            </summary>
      <param name="this">The ReaderWriterLockSlim to provide resource locking</param>
      <param name="lockType">The type of lock to obtain</param>
      <param name="func">The function to perform</param>
    </member>
    <member name="M:W.LockExtensions.ReaderWriterLockSlimExtensions.InLockAsync``1(System.Threading.ReaderWriterLockSlim,W.Threading.Lockers.LockTypeEnum,System.Func{``0})">
      <summary>
            Asynchronously performs the function in a lock
            </summary>
      <param name="this">The ReaderWriterLockSlim to provide resource locking</param>
      <param name="lockType">The type of lock to obtain</param>
      <param name="func">The function to perform</param>
    </member>
    <member name="T:W.PropertyHostExtensions.PropertyHostExtensions">
      <summary>
            Extension methods related to W.PropertyHost or any class which has multiple W.Property members
            </summary>
    </member>
    <member name="M:W.PropertyHostExtensions.PropertyHostExtensions.InitializeProperties(System.Object)">
      <summary>
        <para>
            Scans the fields and properties of "owner" and sets the member's Owner property to "owner"
            This method should be called in the constructor of any class which has IOwnedProperty members
            </para>
      </summary>
      <param name="this">The object on which to find and initialize properties</param>
    </member>
    <member name="M:W.PropertyHostExtensions.PropertyHostExtensions.IsDirty(System.Object)">
      <summary>
        <para>
            Scans the IsDirty value of each field and property of type IProperty 
            </para>
      </summary>
      <param name="this">The object on which to inspect for dirty properties</param>
      <returns>True if any IProperty member's IsDirty value is true, otherwise false</returns>
    </member>
    <member name="M:W.PropertyHostExtensions.PropertyHostExtensions.MarkAsClean(System.Object)">
      <summary>
        <para>
            Scans each field and property of type IProperty and sets it's IsDirty flag to false
            </para>
      </summary>
      <param name="this">The object on which to mark all properties as clean</param>
    </member>
    <member name="T:W.StringExtensions.StringExtensions">
      <summary>
            Extensions for the string type
            </summary>
    </member>
    <member name="M:W.StringExtensions.StringExtensions.IsValidBase64(System.String)">
      <summary>
            Validates the given string conforms to Base64 encoding.  It does not verify the value is a Base64 encoded value.
            </summary>
      <param name="value">The string to test</param>
      <returns>True if the value is valid Base64, otherwise false</returns>
      <remarks>
        <para>This solution is based on a StackOverflow <see href="http://stackoverflow.com/questions/8571501/how-to-check-whether-the-string-is-base64-encoded-or-not">answer</see></para>
      </remarks>
    </member>
    <member name="T:W.ValueChangedDelegate`1">
      <summary>
            Raised when the value has changed
            </summary>
      <param name="sender">The object which raised the event</param>
      <param name="oldValue">The old value</param>
      <param name="newValue">The new value</param>
    </member>
    <member name="T:W.Lockable`1">
      <summary>
        <para>
            Extends LockableSlim with ValueChangedDelegate notification
            </para>
      </summary>
      <typeparam name="TValue">The data Type to be used</typeparam>
    </member>
    <member name="E:W.Lockable`1.ValueChanged">
      <summary>
            Raised when the value has changed
            </summary>
    </member>
    <member name="M:W.Lockable`1.InformWaiters">
      <summary>
            Informs those who are waiting on WaitForChanged that the value has changed
            </summary>
    </member>
    <member name="M:W.Lockable`1.RaiseValueChanged(System.Object,`0,`0)">
      <summary>
            Raises the ValueChanged event
            </summary>
      <param name="oldValue">The previous value</param>
      <param name="newValue">The current value</param>
    </member>
    <member name="M:W.Lockable`1.OnValueChanged(System.Object,`0,`0)">
      <summary>
            Calls RaiseValueChanged to raise the ValueChanged event
            </summary>
      <param name="sender">The object initiating the change</param>
      <param name="oldValue">The previous value</param>
      <param name="newValue">The current value</param>
    </member>
    <member name="M:W.Lockable`1.WaitForValueChanged(System.Int32)">
      <summary>
            Allows the caller to block until Value changes
            </summary>
      <param name="msTimeout">The number of milliseconds to wait for the value to change</param>
      <returns>True if the value changed within the specified timeout period, otherwise False</returns>
    </member>
    <member name="M:W.Lockable`1.SetValue(`0)">
      <summary>
            Sets the value and raises the ValueChanged event
            </summary>
      <param name="newValue">The new value</param>
    </member>
    <member name="M:W.Lockable`1.Dispose">
      <summary>
            Disposes the Lockable and releases resources
            </summary>
    </member>
    <member name="M:W.Lockable`1.#ctor">
      <summary>
            Constructs a new Lockable&lt;TValue&gt;
            </summary>
    </member>
    <member name="M:W.Lockable`1.#ctor(`0)">
      <summary>
            Constructs a new Lockable&lt;TValue&gt;
            </summary>
      <param name="initialValue">The initial value</param>
    </member>
    <member name="M:W.Lockable`1.#ctor(System.Action{System.Object,`0,`0})">
      <summary>
            Constructs a new Lockable&lt;TValue&gt;
            </summary>
      <param name="onValueChanged">The Action to call when the value has changed</param>
    </member>
    <member name="M:W.Lockable`1.#ctor(`0,System.Action{System.Object,`0,`0})">
      <summary>
            Constructs a new Lockable&lt;TValue&gt;
            </summary>
      <param name="initialValue">
      </param>
      <param name="onValueChanged">
      </param>
    </member>
    <member name="T:W.LockableSlim`1">
      <summary>
            Uses ReaderWriterLock to provide thread-safe access to an underlying value
            </summary>
      <typeparam name="TValue">The Type of value</typeparam>
      <remarks>Can be overridden to provide additional functionality</remarks>
    </member>
    <member name="M:W.LockableSlim`1.GetValue">
      <summary>
            Gets the underlying value
            </summary>
    </member>
    <member name="M:W.LockableSlim`1.SetValue(`0)">
      <summary>
            Sets the underlying value
            </summary>
      <param name="value">The new value</param>
    </member>
    <member name="P:W.LockableSlim`1.Value">
      <summary>
            Get or Set the value
            </summary>
      <returns>The current value</returns>
    </member>
    <member name="M:W.LockableSlim`1.#ctor">
      <summary>
            Constructs a new LockableSlim with a default initial value
            </summary>
    </member>
    <member name="M:W.LockableSlim`1.#ctor(`0)">
      <summary>
            Constructs a new LockableSlim assigning an initial value
            </summary>
      <param name="initialValue">The initial value to assign</param>
    </member>
    <member name="T:W.Logging.CustomLogger">
      <summary>
            Allows the programmer to add a custom message logger
            </summary>
    </member>
    <member name="P:W.Logging.CustomLogger.Name">
      <summary>
            The name of this custom logger
            </summary>
    </member>
    <member name="P:W.Logging.CustomLogger.AddTimestamp">
      <summary>
            If true, FormatLogMessage will, by default, add a timestamp prefix to the log message
            </summary>
      <remarks>Note that if FormatLogMessage is overridden, this functionality may be overridden</remarks>
    </member>
    <member name="P:W.Logging.CustomLogger.IsDisposed">
      <summary>
            True if OnDispose has been called
            </summary>
    </member>
    <member name="M:W.Logging.CustomLogger.FormatLogMessage(W.Logging.Log.LogMessageCategory,System.String)">
      <summary>
            Formats the Log Messge (if AddTimestamp is true, the message is prefixed with a timestamp)
            </summary>
      <param name="category">The log message category</param>
      <param name="message">The log message</param>
      <returns>The formatted log message</returns>
    </member>
    <member name="M:W.Logging.CustomLogger.LogMessage(W.Logging.Log.LogMessageCategory,System.String)">
      <summary>
            Log a message to the custom logger
            </summary>
      <param name="category">The log message category</param>
      <param name="message">The log message</param>
    </member>
    <member name="M:W.Logging.CustomLogger.OnDispose">
      <summary>
            Disposes the CustomLogger, releases resources and supresses the finalizer
            </summary>
    </member>
    <member name="M:W.Logging.CustomLogger.Dispose">
      <summary>
            Disposes the CustomLogger and releases resources
            </summary>
    </member>
    <member name="M:W.Logging.CustomLogger.#ctor(System.String,System.Boolean)">
      <summary>
            Constructs a new CustomLogger
            </summary>
      <param name="name">The custom logger name</param>
      <param name="addTimestamp">If True the log messages will be prefixed with a timestamp</param>
    </member>
    <member name="T:W.Logging.Log">
      <summary>
            Exposes static methods for logging.  LogTheMessage can be assigned a new value for customized logging.
            </summary>
    </member>
    <member name="P:W.Logging.Log.LogTheMessage">
      <summary>
            Configure this Action to log messages the way you like to
            </summary>
      <remarks>This method needs to be replaced with something useful to you.</remarks>
    </member>
    <member name="T:W.Logging.Log.LogMessageCategory">
      <summary>
            The log message type
            </summary>
    </member>
    <member name="F:W.Logging.Log.LogMessageCategory.Verbose">
      <summary>
            Denotes verbose message
            </summary>
    </member>
    <member name="F:W.Logging.Log.LogMessageCategory.Information">
      <summary>
            Denotes a informational message
            </summary>
    </member>
    <member name="F:W.Logging.Log.LogMessageCategory.Warning">
      <summary>
            Denotes a warning message
            </summary>
    </member>
    <member name="F:W.Logging.Log.LogMessageCategory.Error">
      <summary>
            Denotes an error message
            </summary>
    </member>
    <member name="M:W.Logging.Log.e(System.Exception)">
            Parameter has no matching param tag in the XML comment (but other parameters do)
            <summary>
            Log an Exception
            </summary><param name="e">The exception to log.  This will be boxed with ToString().</param></member>
    <member name="M:W.Logging.Log.e(System.String,System.Object[])">
      <summary>
            Log a formatted exception message. This method uses string.Format to format the message.
            </summary>
      <param name="format">Format of the message</param>
      <param name="args">Parameters to be passed during message formatting</param>
    </member>
    <member name="M:W.Logging.Log.w(System.String,System.String,System.Int32)">
            Parameter has no matching param tag in the XML comment (but other parameters do)
             <summary>
             Log a formatted warning message. This method uses string.Format to format the message.
             </summary><param name="message">Format of the message</param><param name="callerName">The name of the caller</param><param name="callerLineNumber">The line number of the caller</param></member>
    <member name="M:W.Logging.Log.w(System.String,System.Object[])">
      <summary>
            Log a formatted warning message. This method uses string.Format to format the message.
            </summary>
      <param name="format">Format of the message</param>
      <param name="args">Parameters to be passed during message formatting</param>
    </member>
    <member name="M:W.Logging.Log.i(System.String,System.String,System.Int32)">
            Parameter has no matching param tag in the XML comment (but other parameters do)
            <summary>
            Log a formatted informational message. This method uses string.Format to format the message.
            </summary><param name="message">Format of the message</param><param name="callerName">The name of the caller</param><param name="callerLineNumber">The line number of the caller</param></member>
    <member name="M:W.Logging.Log.i(System.String,System.Object[])">
      <summary>
            Log a formatted informational message. This method uses string.Format to format the message.
            </summary>
      <param name="format">Format of the message</param>
      <param name="args">Parameters to be passed during message formatting</param>
    </member>
    <member name="M:W.Logging.Log.v(System.String,System.String,System.Int32)">
            Parameter has no matching param tag in the XML comment (but other parameters do)
            <summary>
            Log a formatted verbose message. This method uses string.Format to format the message.
            </summary><param name="message">Format of the message</param><param name="callerName">The name of the caller</param><param name="callerLineNumber">The line number of the caller</param></member>
    <member name="M:W.Logging.Log.v(System.String,System.Object[])">
      <summary>
            Log a formatted verbose message. This method uses string.Format to format the message.
            </summary>
      <param name="format">Format of the message</param>
      <param name="args">Parameters to be passed during message formatting</param>
    </member>
    <member name="P:W.Logging.Log.MessageHistory">
      <summary>
            A maintained history of log messages
            </summary>
      <remarks>The default log message limit is 10,000 messages</remarks>
    </member>
    <member name="T:W.Logging.Log.LogMessageHistory">
      <summary>
            Maintains a history of Log information
            </summary>
    </member>
    <member name="T:W.Logging.Log.LogMessageHistory.LogMessage">
      <summary>
            An individual log message
            </summary>
    </member>
    <member name="P:W.Logging.Log.LogMessageHistory.LogMessage.Category">
      <summary>
            The category of the log message
            </summary>
    </member>
    <member name="P:W.Logging.Log.LogMessageHistory.LogMessage.Message">
      <summary>
            The logged message
            </summary>
    </member>
    <member name="M:W.Logging.Log.LogMessageHistory.LogMessage.#ctor">
      <summary>
            Constructs a new LogMessage
            </summary>
    </member>
    <member name="P:W.Logging.Log.LogMessageHistory.Messages">
      <summary>
            The history of log messages
            </summary>
    </member>
    <member name="P:W.Logging.Log.LogMessageHistory.MaximumNumberOfMessages">
      <summary>
            The maximum number of historical messages to maintain.  When the maximum is reached, the oldest messages are removed as needed.
            </summary>
    </member>
    <member name="P:W.Logging.Log.LogMessageHistory.Enabled">
      <summary>
            If True, log messages will be added to the history.  If False, no history is maintained.
            </summary>
    </member>
    <member name="M:W.Logging.Log.LogMessageHistory.#ctor(System.Boolean)">
      <summary>
            Constructs a new LogMessageHistory
            </summary>
      <param name="newestFirst">If True, log messages are inserted at the start of the collection rather than appended to the end</param>
    </member>
    <member name="T:W.IOwnedProperty">
      <summary>
        <para>
            Used by PropertyHostMethods.InitializeProperties to find properties on which to set the owner.  This interface is not used by self-owned properties.
            </para>
      </summary>
    </member>
    <member name="M:W.IOwnedProperty.SetOwner(System.Object)">
      <summary>
            Sets the property owner to the specified value
            </summary>
      <param name="owner">The new property owner</param>
    </member>
    <member name="T:W.IProperty`1">
      <summary>
            The base interface which Property must support
            </summary>
      <typeparam name="TValue">The type of value for the property</typeparam>
    </member>
    <member name="P:W.IProperty`1.Value">
      <summary>
            The value of the property
            </summary>
    </member>
    <member name="T:W.IProperty">
      <summary>
            The base interface which Property must support
            </summary>
    </member>
    <member name="P:W.IProperty.IsDirty">
      <summary>
            True if the property's value has changed since initialization or since the last call to MarkAsClean
            </summary>
    </member>
    <member name="T:W.Property`1">
      <summary>
            A Property with no owner (self-owned)
            </summary>
      <typeparam name="TValue">The type of the property value</typeparam>
    </member>
    <member name="T:W.Property`2">
      <summary>
            A generic Property with an owner
            </summary>
      <typeparam name="TOwner">The type of owner</typeparam>
      <typeparam name="TValue">The type of the property value</typeparam>
    </member>
    <member name="M:W.Property`2.#ctor">
      <summary>
            Constructs a new Property
            </summary>
    </member>
    <member name="M:W.Property`2.#ctor(`0)">
      <summary>
            Constructs a new Property
            </summary>
      <param name="owner">The owner of the property</param>
    </member>
    <member name="M:W.Property`2.#ctor(`1)">
      <summary>
            Constructs a new Property
            </summary>
      <param name="defaultValue">The default and initial value of the property</param>
    </member>
    <member name="M:W.Property`2.#ctor(`0,`1)">
      <summary>
            Constructs a new Property
            </summary>
      <param name="owner">The owner of the property</param>
      <param name="defaultValue">The default and initial value of the property</param>
    </member>
    <member name="P:W.PropertyBase`2.IsDirty">
      <summary>
            True if Value has changed since initialization or since the last call to MarkAsClean
            </summary>
    </member>
    <member name="P:W.PropertyBase`2.Owner">
      <summary>
            The property owner
            </summary>
    </member>
    <member name="P:W.PropertyBase`2.DefaultValue">
      <summary>
        <para>
            Allows the programmer to assign a default value which can be reset via the ResetToDefaultValue method. This value does not have to be the initial value.
            </para>
      </summary>
    </member>
    <member name="M:W.PropertyBase`2.ResetToDefaultValue(System.Boolean)">
      <summary>
            Resets the Value to the value provided by DefaultValue
            </summary>
      <param name="raise">If True, raise OnPropertyChanged event and call the OnValueChanged callback</param>
    </member>
    <member name="M:W.PropertyBase`2.OnPropertyChanging(System.String)">
      <summary>
        <para>
            Calls RaisePropertyChanging to raise the PropertyChanging event
            </para>
      </summary>
      <param name="propertyName">The name of the caller (the property which changed)</param>
    </member>
    <member name="M:W.PropertyBase`2.OnPropertyChanged(System.String)">
      <summary>
        <para>
            Calls RaisePropertyChanged to raise the PropertyChanged event
            </para>
      </summary>
      <param name="propertyName">The name of the caller (the property which changed)</param>
    </member>
    <member name="M:W.PropertyBase`2.OnValueChanged(System.Object,`1,`1)">
      <summary>
            Calls RaiseValueChanged to raise the ValueChanged event
            </summary>
      <param name="sender">The property owner</param>
      <param name="oldValue">The previous value</param>
      <param name="newValue">The current value</param>
    </member>
    <member name="M:W.PropertyBase`2.LoadValue(`1)">
      <summary>
            Sets Value without raising notification events
            </summary>
    </member>
    <member name="T:W.PropertyChangedNotifier">
      <summary>
        <para>
            This is a base class for supporting INotifyPropertyChanged
            </para>
      </summary>
    </member>
    <member name="E:W.PropertyChangedNotifier.PropertyChanged">
      <summary>
            Raised when a property changes
            </summary>
    </member>
    <member name="M:W.PropertyChangedNotifier.GetValue">
      <summary>
        <para>
            Override this method to provide Get functionality
            </para>
      </summary>
      <returns>Unless overridden, this function will always return null</returns>
    </member>
    <member name="M:W.PropertyChangedNotifier.SetValue(System.Object,System.String)">
      <summary>
        <para>
            Calls OnPropertyChanged.  This method does not make assignments.  Override this method to make assignments.
            </para>
      </summary>
      <param name="value">The new value</param>
      <param name="propertyName">The name of the caller (the property being set)</param>
    </member>
    <member name="M:W.PropertyChangedNotifier.OnPropertyChanged(System.String)">
      <summary>
        <para>
            Calls RaisePropertyChanged to raise the PropertyChanged event
            </para>
      </summary>
      <param name="propertyName">The name of the caller (the property which changed)</param>
    </member>
    <member name="M:W.PropertyChangedNotifier.RaiseOnPropertyChanged(System.Object,System.String)">
      <summary>
        <para>
            Raises the PropertyChanged event
            </para>
      </summary>
      <param name="sender">The sender is the owner of the property</param>
      <param name="propertyName">The name of the caller (the property which changed)</param>
    </member>
    <member name="T:W.PropertyHost">
      <summary>
        <para>
            Provides a base class to automate the IsDirty, MarkAsClean and InitializeProperties functionality
            Note that this class does not support INotifyPropertyChanged and is not intented to host owned properties (though nothing prevents you from doing so)
            </para>
      </summary>
    </member>
    <member name="P:W.PropertyHost.IsDirty">
      <summary>
            Finds all Properties and checks their IsDirty flag
            </summary>
      <returns>True if any Property's IsDirty flag is true. Otherwise false.</returns>
    </member>
    <member name="M:W.PropertyHost.MarkAsClean">
      <summary>
            Uses reflection to find all Properties and mark them as clean (call Property.MarkAsClean())
            </summary>
    </member>
    <member name="M:W.PropertyHost.#ctor">
      <summary>
            Calls PropertyHostExtensions.InitializeProperties so you don't have to
            </summary>
    </member>
    <member name="T:W.PropertyHostNotifier">
      <summary>
        <para>
            Provides a base class to automate the IsDirty, MarkAsClean and InitializeProperties functionality
            Note that this class inherits PropertyChangedNotifier for INotifyPropertyChanged support
            </para>
      </summary>
    </member>
    <member name="P:W.PropertyHostNotifier.IsDirty">
      <summary>
            Finds all Properties and checks their IsDirty flag
            </summary>
      <returns>True if any Property's IsDirty flag is true. Otherwise false.</returns>
    </member>
    <member name="M:W.PropertyHostNotifier.MarkAsClean">
      <summary>
            Uses reflection to find all Properties and mark them as clean (call Property.MarkAsClean())
            </summary>
    </member>
    <member name="M:W.PropertyHostNotifier.#ctor">
      <summary>
            Calls PropertyHostMethods.InitializeProperties so you don't have to
            </summary>
    </member>
    <member name="M:W.PropertySlim`1.RaiseOnPropertyChanging(System.Object,System.String)">
      <summary>
        <para>
            Raises the PropertyChanging event
            </para>
      </summary>
      <param name="sender">The sender is the owner of the property</param>
      <param name="propertyName">The name of the caller (the property which changing)</param>
    </member>
    <member name="M:W.PropertySlim`1.OnPropertyChanging(System.String)">
      <summary>
        <para>
            Calls RaisePropertyChanging to raise the PropertyChanging event
            </para>
      </summary>
      <param name="propertyName">The name of the caller (the property which changed)</param>
    </member>
    <member name="M:W.PropertySlim`1.RaiseOnPropertyChanged(System.Object,System.String)">
      <summary>
        <para>
            Raises the PropertyChanged event
            </para>
      </summary>
      <param name="sender">The sender is the owner of the property</param>
      <param name="propertyName">The name of the caller (the property which changed)</param>
    </member>
    <member name="M:W.PropertySlim`1.OnPropertyChanged(System.String)">
      <summary>
        <para>
            Calls RaisePropertyChanged to raise the PropertyChanged event
            </para>
      </summary>
      <param name="propertyName">The name of the caller (the property which changed)</param>
    </member>
    <member name="M:W.PropertySlim`1.SetValue(`0)">
      <summary>
        <para>
            Calls OnPropertyChanged on assignment
            </para>
      </summary>
      <param name="value">The new value</param>
      <param name="propertyName">The name of the caller (the property being set)</param>
    </member>
    <member name="T:W.Singleton`1">
      <summary>
            Thread-safe Singleton implementation
            </summary>
      <typeparam name="TSingletonType">The singleton Type</typeparam>
      <remarks>Adapted from MSDN article "Implementing Singleton in C#"</remarks>
      <see ref="https://msdn.microsoft.com/en-us/library/ff650316.aspx">MSDN Article: Implementing Singleton in C#</see>
    </member>
    <member name="P:W.Singleton`1.Instance">
      <summary>
            Returns the singleton
            </summary>
    </member>
    <member name="N:W">
      <summary>The root namespace for Tungsten.  W is used because it is the symbol for Tungsten on the periodic table of elements.</summary>
    </member>
    <member name="N:W.AsExtensions">
      <summary>Extensions which convert objects to another</summary>
    </member>
    <member name="N:W.DelegateExtensions">
      <summary>Extension methods for delegates</summary>
    </member>
    <member name="N:W.Encryption">
      <summary>Functionality related to encryption</summary>
    </member>
    <member name="N:W.FromExtensions">
      <summary>Extensions which convert objects from one type to another</summary>
    </member>
    <member name="N:W.InvokeExtensions">
      <summary>Extensions to provide code shortcuts to evaluate InvokeRequired and run code appropriately</summary>
    </member>
    <member name="N:W.LockExtensions">
      <summary>Extension methods for object, SpinLock, SemaphoreSlim, ReaderWriterLockSlim to provide less verbose resource locking</summary>
    </member>
    <member name="N:W.Logging">
      <summary>Functionality related to information and error logging</summary>
    </member>
    <member name="N:W.PropertyHostExtensions">
      <summary>Extension methods related to W.PropertyHost or any class which has one or more W.Property members</summary>
    </member>
    <member name="N:W.StringExtensions">
      <summary>Extensions for the string type</summary>
    </member>
    <member name="N:W.Threading">
      <summary>Functionality related to multi-threading</summary>
    </member>
    <member name="N:W.Threading.GateExtensions">
      <summary>Extension methods on Action to Create a Gate</summary>
    </member>
    <member name="N:W.Threading.Lockers">
      <summary>Lockers are designed to make locking of thread resources easier and less verbose</summary>
    </member>
    <member name="N:W.Threading.ThreadExtensions">
      <summary>Extension methods related to threading</summary>
    </member>
  </members>
</doc>